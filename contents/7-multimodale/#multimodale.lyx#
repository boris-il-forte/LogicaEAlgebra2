#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble


\title{Logica e Algebra 2}

\usepackage[english]{babel}
\usepackage{tikz}

\usepackage{settings/usefulMacros} 

\usepackage{booktabs}\usepackage{listings}\lstset{columns=fullflexible}

\usepackage{wasysym}

\usepackage{amsthm}\newtheoremstyle{note} % name
{\topsep} 	% Space above
{\topsep} 	% Space below
{\small}		% Body font
{}		% Indent amount
{\small\bfseries}% Theorem head font
{:}		% Punctuation after theorem head
{.5em}	% Space after theorem head
{}		% Theorem head spec (can be left empty, meaning ‘normal’)

\usepackage{fancyhdr}%% Cambia il carattere delle didascalie delle figure %%
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

\usepackage{comment}

%per le tabelle lunghe e particolari
\usepackage{lscape}



\usepackage{babel}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding T1
\font_roman default
\font_sans default
\font_typewriter mathpazo
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{savequote}[50mm]
\end_layout

\begin_layout Plain Layout

---Marty, non stai pensando quadridimensionalmente!---
\end_layout

\begin_layout Plain Layout


\backslash
qauthor{Emmett Brown} 
\end_layout

\begin_layout Plain Layout

---Sono in ritardo! In arciritardissimo!---
\end_layout

\begin_layout Plain Layout


\backslash
qauthor{Bianconiglio} 
\backslash
end{savequote}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Logica Multimodale - Back To The Future
\end_layout

\begin_layout Section
Logiche multimodali
\end_layout

\begin_layout Standard
una logica multimodale è una logica che definisce oltre ai normali operatori
 della logica proposizionale gli operatori:
\end_layout

\begin_layout Standard
\begin_inset Formula $[i]$
\end_inset

 con 
\begin_inset Formula $i\in I$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $<i>\equiv\neg[i]\neg$
\end_inset


\end_layout

\begin_layout Standard
definita sul frame:
\end_layout

\begin_layout Standard
\begin_inset Formula $F=(S,\{R_{i}\,|\, i\in I\})$
\end_inset

 
\end_layout

\begin_layout Standard
La semantica di una logica multimodale è la stessa della logica proposizionale
 per gli operatori comuni, mentre gli operatori box hanno la seguente semantica:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw\mu\alpha{\neci ia}\iff\veraw\mu\beta a\,\forall\beta\,:\,(\alpha,\,\beta)\in R_{i}$
\end_inset


\end_layout

\begin_layout Standard
Chiamiamo assioma 
\begin_inset Formula $K_{i}$
\end_inset

 la seguente formula:
\end_layout

\begin_layout Standard
\begin_inset Formula $K_{i}$
\end_inset

: 
\begin_inset Formula $\neci i{(a\implies b)}\implies(\neci ia\implies\neci i{b)}$
\end_inset


\end_layout

\begin_layout Standard
Tutte le logiche multimodali normali devono contenere:
\end_layout

\begin_layout Standard
gli assiomi 
\begin_inset Formula $K_{i}$
\end_inset

 
\begin_inset Formula $\forall i\in I$
\end_inset


\end_layout

\begin_layout Standard
le regole di necessitazione:
\end_layout

\begin_layout Standard
\begin_inset Formula $RN_{i}:$
\end_inset

 
\begin_inset Formula $\dfrac{a}{\neci ia}$
\end_inset

 
\begin_inset Formula $\forall i\in I$
\end_inset


\end_layout

\begin_layout Section
Futuro e Passato
\end_layout

\begin_layout Standard
Possiamo applicare le logiche multimodali al concetto di tempo, per farlo
 consideriamo il frame:
\end_layout

\begin_layout Standard
\begin_inset Formula $F=(S,\,\{R_{P},\, R_{F}\})$
\end_inset


\end_layout

\begin_layout Standard
da cui possiamo ricavare gli operatori modali:
\end_layout

\begin_layout Standard
\begin_inset Formula $[P]$
\end_inset

 e 
\begin_inset Formula $[F]$
\end_inset


\end_layout

\begin_layout Standard
ricordiamo che:
\end_layout

\begin_layout Standard
\begin_inset Formula $<P>\equiv\neg[P]\neg$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $<F>\equiv\neg[F]\neg$
\end_inset


\end_layout

\begin_layout Standard
Perché le due relazioni rappresentino il tempo che scorre una deve essere
 l'opposta dell'altra, in modo che la prima relazione rappresenti il futuro,
 la seconda il passato:
\end_layout

\begin_layout Standard
\begin_inset Formula $\alpha R_{P}\beta\iff\beta R_{F}\alpha$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R_{p}=R_{f}^{-1}$
\end_inset


\end_layout

\begin_layout Standard
Questa proprietà si può dimostrare equivalente ai due assiomi:
\end_layout

\begin_layout Standard
\begin_inset Formula $B_{PF}:$
\end_inset

 
\begin_inset Formula $a\implies\necp{\posf a}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $B_{FP}:$
\end_inset

 
\begin_inset Formula $a\implies\necf{\posp a}$
\end_inset


\end_layout

\begin_layout Subsection
Dimostrazione
\end_layout

\begin_layout Standard
Ip) 
\begin_inset Formula $\veraw\mu\alpha a$
\end_inset

 e 
\begin_inset Formula $\forall\beta\,:\,(\alpha,\,\beta)\in R_{P}\iff(\beta,\,\alpha)\in R_{F}$
\end_inset


\end_layout

\begin_layout Standard
Ts) 
\begin_inset Formula $\veraw\mu\alpha{a\implies\necp{\posf a}}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ogni mondo 
\begin_inset Formula $\beta$
\end_inset

 raggiunge 
\begin_inset Formula $\alpha$
\end_inset

 tramite 
\begin_inset Formula $R_{F}$
\end_inset

, e quindi:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw\mu\beta{\posf a}$
\end_inset


\end_layout

\begin_layout Standard
allora, usando la regola di necessitazione nel passato, possiamo scrivere:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw\mu\alpha{\necp{\posf a}}$
\end_inset


\end_layout

\begin_layout Standard
ma poiché per ipotesi in 
\begin_inset Formula $\alpha$
\end_inset

 è vera a:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw\mu\alpha{\necp{\posf a}}$
\end_inset


\end_layout

\begin_layout Standard
poiché abbiamo preso un 
\begin_inset Formula $\alpha$
\end_inset

 generico, la tesi è dimostrata.
\begin_inset Newline newline
\end_inset

Ip) 
\begin_inset Formula $\veraw\mu\alpha{a\implies\necp{\posf a}}$
\end_inset


\end_layout

\begin_layout Standard
Ts) 
\begin_inset Formula $R_{F}=R_{P}^{-1}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
per assurdo 
\begin_inset Formula $R_{F}\neq R_{p}^{-1}$
\end_inset


\end_layout

\begin_layout Standard
prendiamo allora un mondo 
\begin_inset Formula $\alpha$
\end_inset

 in cui a 
\begin_inset Formula $R_{P}$
\end_inset

 non corrisponda l'arco inverso nella relazione 
\begin_inset Formula $R_{F}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $V(A)=\{\alpha\}$
\end_inset


\end_layout

\begin_layout Standard
allora in 
\begin_inset Formula $\beta$
\end_inset

 poiché non si raggiunge tramite 
\begin_inset Formula $R_{P}$
\end_inset

 il mondo 
\begin_inset Formula $\alpha$
\end_inset

 vale:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw\mu\beta{\posf A}$
\end_inset


\end_layout

\begin_layout Standard
ma poiché 
\begin_inset Formula $\beta$
\end_inset

 è raggiungibile da 
\begin_inset Formula $\alpha$
\end_inset

 tramite 
\begin_inset Formula $R_{P}$
\end_inset

 abbiamo:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw\mu\alpha{\necp{\posf A}}$
\end_inset


\end_layout

\begin_layout Standard
Ma allora, poiché in 
\begin_inset Formula $\alpha$
\end_inset

 è vera A:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw\mu\alpha{A\implies\necp{\posf A}}$
\end_inset


\end_layout

\begin_layout Standard
Assurdo! allora la tesi è dimostrata.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.2] 
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{every node}+=[inner sep=0pt] 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (17,-27.7) circle (3); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (17,-27.7) node {$
\backslash
alpha$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (37.7,-27.7) circle (3); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (37.7,-27.7) node {$
\backslash
beta$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (59.2,-17.2) circle (3); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (59.2,-17.2) node {$...$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (60,-38.3) circle (3); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (60,-38.3) node {$...$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw (17,-23.6) node {$A$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw (37.7,-23.6) node {
\backslash
sout{$
\backslash
posf{A}$}}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw (17,-21.4) node {
\backslash
sout{$
\backslash
necp{
\backslash
posf{A}}$}}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw (17,-19.1) node {
\backslash
sout{$A
\backslash
implies 
\backslash
necp{
\backslash
posf{A}}$}}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (40.641,-28.292) arc (76.71074:52.44238:44.889);
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (57.68,-36.39) -- (57.36,-35.51) -- (56.75,-36.3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (51.76,-30.92) node [above] {$R_P$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (39.988,-25.761) arc (128.26646:103.79273:42.728);
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (56.26,-17.81) -- (55.37,-17.52) -- (55.61,-18.49); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (45.52,-20.4) node [above] {$R_P$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (20,-27.7) -- (34.7,-27.7);
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (34.7,-27.7) -- (33.9,-27.2) -- (33.9,-28.2);
\end_layout

\begin_layout Plain Layout


\backslash
draw (27.35,-28.2) node [below] {$R_P$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (56.855,-19.07) arc (-53.2117:-74.72911:48.403);
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (40.62,-27) -- (41.52,-27.27) -- (41.26,-26.31);
\end_layout

\begin_layout Plain Layout


\backslash
draw (51.28,-24.31) node [below] {$R_F$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (57.059,-37.71) arc (-103.2634:-127.58348:44.797); 
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (40.01,-29.61) -- (40.34,-30.49) -- (40.95,-29.7); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (45.94,-35.08) node [below] {$R_F$}; 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Frame Temporale
\end_layout

\begin_layout Standard
Un frame temporale è un frame così composto:
\end_layout

\begin_layout Standard
\begin_inset Formula $F=(S,\, R_{F})$
\end_inset


\end_layout

\begin_layout Standard
con 
\begin_inset Formula $R_{F}=R_{p}^{-1}$
\end_inset

 e 
\begin_inset Formula $R_{F}$
\end_inset

 transitiva.
\end_layout

\begin_layout Standard
In un frame temporale devono valere gli assiomi:
\end_layout

\begin_layout Standard
A1, A2, A3, 
\begin_inset Formula $K_{P}$
\end_inset

, 
\begin_inset Formula $K_{F}$
\end_inset

, 
\begin_inset Formula $4_{P}$
\end_inset

, 
\begin_inset Formula $4_{F}$
\end_inset

, 
\begin_inset Formula $B_{FP}$
\end_inset

, 
\begin_inset Formula $B_{PF}$
\end_inset


\end_layout

\begin_layout Standard
dove gli assiomi che esprimono la transitività sono:
\end_layout

\begin_layout Standard
\begin_inset Formula $4_{P}$
\end_inset

: 
\begin_inset Formula $\necf a\implies\necf{\necf a}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $4_{F}$
\end_inset

: 
\begin_inset Formula $\necp a\implies\necp{\necp a}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $B_{PF}:$
\end_inset

 
\begin_inset Formula $a\implies\necp{\posf a}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $B_{FP}:$
\end_inset

 
\begin_inset Formula $a\implies\necf{\posp a}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Una logica temporale è una logica normale multimodale nei connettivi modali
 [F] e [P]
\end_layout

\begin_layout Standard
che contiene gli schemi 
\begin_inset Formula $B_{FP}$
\end_inset

 
\begin_inset Formula $B\mbox{\ensuremath{_{PF}}}$
\end_inset


\begin_inset Formula $4_{P}$
\end_inset

 
\begin_inset Formula $4_{F}$
\end_inset

.
\end_layout

\begin_layout Standard
Si dice logica lineare temporale ogni logica normale che contiene la minima
\end_layout

\begin_layout Standard
logica normale temporale 
\begin_inset Formula $Kt$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Kt$
\end_inset

 si assiomatizza con 
\begin_inset Formula $A1,\ A2,\ A3,\ MP,\ K_{P},\ K_{F},\ B_{PF},\ B_{FP},\ 4_{P},\ 4_{F},\ RN_{P},\ RN_{F}$
\end_inset


\end_layout

\begin_layout Section
Correttezza, completezza e decidibilità nelle logiche multimodali
\end_layout

\begin_layout Standard
Possiamo seguire lo stesso schema di dimostrazioni usato nella logica unimodale
 per dimostrare la correttezza, completezza e decidibilità delle logiche
 multimodali.
 Bisogna tuttavia ridefinire alcuni dettagli, ossia il teorema di raggiungibilit
à e la 
\begin_inset Formula $\Gamma$
\end_inset

-Filtrazione
\end_layout

\begin_layout Subsection
Teorema di Raggiungibilità
\end_layout

\begin_layout Standard
\begin_inset Formula $(\alpha,\,\beta)\in R^{\Lambda}$
\end_inset


\end_layout

\begin_layout Standard
è equivalente a:
\end_layout

\begin_layout Standard
\begin_inset Formula $\{a\,|\,\necf a\in\alpha\}\subseteq\beta$
\end_inset


\end_layout

\begin_layout Standard
oppure:
\end_layout

\begin_layout Standard
\begin_inset Formula $\{\posf{b\,|\, b\in\beta\}\subseteq\alpha}$
\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Formula $\Gamma$
\end_inset

-Filtrazione
\end_layout

\begin_layout Standard
Bisogna, nel caso delle logiche multimodali, ridefinire il concetto di relazione
 filtrata R'.
\end_layout

\begin_layout Standard
R' infatti dovrà ora soddisfare le tre seguenti proprietà:
\end_layout

\begin_layout Standard
F1) 
\begin_inset Formula $(\alpha,\,\beta)\in R\implies([\alpha],\,[\beta])\in R'$
\end_inset


\end_layout

\begin_layout Standard
F2) 
\begin_inset Formula $([\alpha],\,[\beta])\in R'\implies(\forall\necf b\in\Gamma\,\veraw{\mu}{\alpha}{\necf b}\implies\veraw{\mu}{\beta}b)$
\end_inset


\end_layout

\begin_layout Standard
F3) 
\begin_inset Formula $([\alpha],\,[\beta])\in R'\implies(\forall\necp b\in\Gamma\,\veraw{\mu}{\beta}{\necp b}\implies\veraw{\mu}{\alpha}b)$
\end_inset


\end_layout

\begin_layout Section
Distinzione tra (
\begin_inset Formula $\mathbb{Q}$
\end_inset

 ,<) e (
\begin_inset Formula $\mathbb{R}$
\end_inset

 ,<)
\end_layout

\begin_layout Standard
Nella logica unimodale non siamo in grado di distinguere i frame (
\begin_inset Formula $\mathbb{Q}$
\end_inset

 ,<) e (
\begin_inset Formula $\mathbb{R}$
\end_inset

 ,<), entrambi sono espressi dalla logica K4DLX
\end_layout

\begin_layout Standard
Per convenzione poniamo:
\end_layout

\begin_layout Standard
\begin_inset Formula $\boa\equiv\necp a\wedge a\wedge\necf a$
\end_inset


\end_layout

\begin_layout Standard
L'assioma che esprime la continuità della relazione è il seguente:
\end_layout

\begin_layout Standard
Cont: 
\begin_inset Formula $\boxx{(\necp a\implies\posf{\necp{a)}}\implies(\necp a\implies\necf{a)}}$
\end_inset


\end_layout

\begin_layout Standard
Si dimostra che:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonvera{(\mathbb{Q},<)}{Cont}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\vera{(\mathbb{R},<)}{Cont}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Ip) 
\begin_inset Formula $V(A)=\{q\in\mathbb{Q}\,|\, q<\sqrt{2}\}$
\end_inset


\end_layout

\begin_layout Standard
Ts) 
\begin_inset Formula $\nonvera{(\mathbb{Q},<)}{Cont}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Preso 
\begin_inset Formula $\alpha<\sqrt{2}$
\end_inset

, varranno:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw{\mu}{\alpha}{\necp A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw{\mu}{\alpha}{\necf A}$
\end_inset


\end_layout

\begin_layout Standard
e quindi possiamo scrivere 
\begin_inset Formula $\forall\alpha<\sqrt{2}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw{\mu}{\alpha}{\necp A\implies\necf A}$
\end_inset


\end_layout

\begin_layout Standard
Tuttavia l'antecedente di Cont è vero, infatti 
\begin_inset Formula $\forall\alpha<\sqrt{2}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw{\mu}{\alpha}{\posf{\necp A}}$
\end_inset

 
\end_layout

\begin_layout Standard
e quindi l'antecedente di Cont è vero
\end_layout

\begin_layout Standard
mentre 
\begin_inset Formula $\forall\alpha>\sqrt{2}$
\end_inset

 vale:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw{\mu}{\alpha}{\necp A}$
\end_inset


\end_layout

\begin_layout Standard
e quindi l'antecedente di Cont è ancora vero.
\end_layout

\begin_layout Standard
Poiché l'antecedente di Cont è sempre vero, mentre la conseguenza no, allora:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonvera{(\mathbb{Q},<)}{Cont}$
\end_inset


\end_layout

\begin_layout Standard
e la tesi è dimostrata.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
definecolor{cc60000}{RGB}{198,0,0} 
\backslash
definecolor{c800000}{RGB}{128,0,0}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[y=0.80pt,x=0.80pt,yscale=-1, 
\end_layout

\begin_layout Plain Layout

inner sep=0pt, outer sep=0pt] 
\backslash
begin{scope}[shift={(0,-752.36216)}] 
\end_layout

\begin_layout Plain Layout

 
\backslash
path[shift={(0,752.36216)},draw=black,line join=miter,line 
\end_layout

\begin_layout Plain Layout

cap=butt,line     width=0.800pt] (30.0000,55.0000) -- (578.6159,55.0000);
\end_layout

\begin_layout Plain Layout

  
\backslash
path[draw=cc60000,fill=c800000,line join=miter,line cap=butt,line    
\end_layout

\begin_layout Plain Layout

width=1.176pt] (318.0000,789.0651) ..
 controls (317.7036,818.9733)
\end_layout

\begin_layout Plain Layout

and     (318.0000,817.6504) ..
 (318.0000,817.6504);  
\end_layout

\begin_layout Plain Layout


\backslash
path[shift={(0,752.36216)},fill=black] (344.70734,136.11012) node[above right]
  
\end_layout

\begin_layout Plain Layout

  (text3993) {};  
\end_layout

\begin_layout Plain Layout


\backslash
path[fill=black] (305.92676,776.86609) 
\end_layout

\begin_layout Plain Layout

node[above right] (text4078) {$
\backslash
sqrt{2}$}; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[shift={(0,752.36216)},fill=black] 
\end_layout

\begin_layout Plain Layout

(489.36133,76.863548) node[above right]     (text4105) {};  
\end_layout

\begin_layout Plain Layout


\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.710pt]  
\end_layout

\begin_layout Plain Layout

  (254.0000,817.9182) -- (254.0000,788.8061);   
\backslash
path[fill=black]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

(235.91389,777.67352) node[above right] (text4228) {$
\backslash
alpha$};  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[cm={{0.09011,0.0,0.0,0.12041,(552.7687,781.39932)}},draw=black,fill=black]
   
\end_layout

\begin_layout Plain Layout

 (354.7100,211.5149) -- (302.2148,240.5337) -- (250.8362,271.4865) -- 
\end_layout

\begin_layout Plain Layout

   (251.9528,211.5149) -- (250.8362,151.5433) -- (302.2148,182.4960) -- cycle;
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ip) 
\begin_inset Formula $\delta=\max\limits _{\eta\in\mathbb{R}}(\veraw{\mu}{\eta}{A\,\eta<\delta)}$
\end_inset


\end_layout

\begin_layout Standard
Ts) 
\begin_inset Formula $\vera{(\mathbb{R},<)}{Cont}$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $\forall\alpha>\delta$
\end_inset

: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonvera{\mu}{[P]A}$
\end_inset

 da cui 
\begin_inset Formula $\vera{\mu}{\text{[P]A\implies[F]A}}$
\end_inset

 da cui 
\begin_inset Formula $\vera{\mu}{Cont}$
\end_inset

 dato che il conseguente è vero e quindi non devo controllare l'antecedente.
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall\alpha<\delta$
\end_inset

 possiamo scrivere:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw{\mu}{\alpha}{\necp A}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw{\mu}{\alpha}{\necf A}$
\end_inset


\end_layout

\begin_layout Standard
Tuttavia l'antecedente di Cont è falso, infatti:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw{\mu}{\delta}{\necp A}$
\end_inset


\end_layout

\begin_layout Standard
ma poiché non può esistere nessun mondo 
\begin_inset Formula $\xi>\delta$
\end_inset

 in cui sia vera A, essendo 
\begin_inset Formula $\delta$
\end_inset

 massimo, avremo che:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonveraw{\mu}{\delta}{\posf{\necp A}}$
\end_inset


\end_layout

\begin_layout Standard
e quindi non potrà che essere che:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonvera{\mu}{_{\delta}\necp A\implies\posf{\necp A}}$
\end_inset


\end_layout

\begin_layout Standard
Poiché 
\begin_inset Formula $\delta$
\end_inset

 è raggiungibile da 
\begin_inset Formula $\alpha$
\end_inset

 avremo che:
\end_layout

\begin_layout Standard
\begin_inset Formula $\nonvera{\mu}{_{\alpha}\boxx{(\necp A\implies\posf{\necp A})}}$
\end_inset


\end_layout

\begin_layout Standard
e quindi 
\begin_inset Formula $\veraw{\mu}{\alpha}{Cont}$
\end_inset

, inoltre 
\begin_inset Formula $Cont$
\end_inset

 è vero in 
\begin_inset Formula $\delta$
\end_inset

 dato che l'antecedente è falso perché se 
\begin_inset Formula $\nonvera{\mu}{_{\delta}\necp A\implies\posf{\necp A}}$
\end_inset

, allora anche 
\begin_inset Formula $\nonvera{\mu}{_{\delta}\boxx{}\necp A\implies\posf{\necp A}}$
\end_inset


\end_layout

\begin_layout Standard
allora avremo che in 
\begin_inset Formula $\alpha$
\end_inset

 l'antecedente di Cont è falso solo quando è falso il conseguente, e quindi
 il teorema è dimostrato.
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[y=0.80pt,x=0.80pt,yscale=-1, inner sep=0pt, outer sep=0pt]
 
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[shift={(0,-752.36216)}]  
\end_layout

\begin_layout Plain Layout


\backslash
path[shift={(0,752.36216)},draw=black,line join=miter,line cap=butt,line
   
\end_layout

\begin_layout Plain Layout

 width=0.800pt] (30.0000,55.0000) -- (578.6159,55.0000);  
\end_layout

\begin_layout Plain Layout


\backslash
path[shift={(0,752.36216)},fill=black] (344.70734,136.11012) node[above right]
     (text3993) {};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[fill=black] (360.87012,839.06793) node[above right] (text4078) {$
\backslash
gamma$};  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[shift={(0,752.36216)},fill=black] (489.36133,76.863548) node[above right]
    (text4105) {}; 
\end_layout

\begin_layout Plain Layout


\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.777pt] 
\end_layout

\begin_layout Plain Layout

(276.0850,827.9182) -- (276.0850,799.3622);  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[fill=black] (210.22182,794.57617) node[above right] (text4228) {$
\backslash
alpha$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
path[cm={{0.09011,0.0,0.0,0.12041,(552.7687,781.39932)}},draw=black,fill=black]
  
\end_layout

\begin_layout Plain Layout

  (354.7100,211.5149) -- (302.2148,240.5337) -- (250.8362,271.4865) --    
\end_layout

\begin_layout Plain Layout

(251.9528,211.5149) -- (250.8362,151.5433) -- (302.2148,182.4960) -- cycle; 
\end_layout

\begin_layout Plain Layout

 
\backslash
path[shift={(0,752.36216)},draw=black,line join=miter,line cap=butt,line
 
\end_layout

\begin_layout Plain Layout

   width=0.800pt] (230.0000,54.5911) -- (230.0000,90.0000) -- (30.0000,90.0000);
  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[fill=black] (263.79507,789.35651) node[above right] (text4725) {[p]a};
  
\end_layout

\begin_layout Plain Layout


\backslash
path[fill=black] (262.00568,840.79724) node[above right] (text4729) {$
\backslash
delta$};  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
path[shift={(0,752.36216)},draw=black,line join=miter,line cap=butt,line
    
\end_layout

\begin_layout Plain Layout

width=0.800pt] (359.6890,47.0000) -- (359.6890,75.7800); 
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questo significa che esiste una differente potenza espressiva tra la logica
 unimodale e la logica multimodale.
\end_layout

\begin_layout Section
Logica della concorrenza
\end_layout

\begin_layout Standard
Una logica che si presta bene a descrivere la concorrenza, cioè un insieme
 di n diversi processi che agiscono in parallelo, condividendo la memoria,
 in modo che ogni processo può alterare i valori di variabili usate anche
 dagli altri, è la logica nota sotto il nome di LTL (linear temporal logic)
 o di logica delle concorrenza.
\begin_inset Newline newline
\end_inset

Si introducono l'operatore unario 
\begin_inset Formula $\circ$
\end_inset

 e l'operatore binario 
\begin_inset Formula $U$
\end_inset


\begin_inset Newline newline
\end_inset

La semantica di questa logica è espressa tramite il frame detto 
\series bold
sequenza di stati
\series default
 che è costituito da una coppia (S,
\begin_inset Formula $\sigma$
\end_inset

) dove S è al solito un insieme di stati e 
\begin_inset Formula $\sigma$
\end_inset

 è una funzione suriettiva da 
\begin_inset Formula $\omega$
\end_inset

 ad S e enumera gli stati di S disponendoli in sequenza (con eventuali elementi
 ripetuti)
\end_layout

\begin_layout Standard
La funzione di valutazione V si da in modo consueto, tranne che per i seguenti:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw Mj{\circ}a$
\end_inset

, se e solo se 
\begin_inset Formula $\veraw M{j+1}a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw Mj{\boa}$
\end_inset

, se e solo se 
\begin_inset Formula $\veraw Mka$
\end_inset

 per ogni 
\begin_inset Formula $k\geq j$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw Mj{aUb}$
\end_inset

, se e solo se 
\begin_inset Formula $\veraw Mkb$
\end_inset

 per qualche 
\begin_inset Formula $k\geq j$
\end_inset

 e 
\begin_inset Formula $\veraw Mia$
\end_inset

 per ogni i con
\begin_inset Formula $j\leq i<k$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Questa logica si può assiomatizzare con i seguenti:
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $K_{\square}:\ \boxx{(\implica a{b)\implies(\boa\implies\boxx{b)}}}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $K_{\circ}:\ \circ(\implica a{b)\implies(\circ a\implies\circ b)}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Fun:\ \circ\neg a\iff\neg\circ a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Mix:\ \boxx{a\implies a\wedge\circ\boa}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Ind:\ \boxx{(a\implies\circ a)\implies(a\implies\boa)}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $U1:\ aUb\implies\diam b$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $U2:\ aUb\iff b\vee(a\wedge\circ(aUb))$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Si dimostra che LTL è determinata dai frame sequenza di stati.
\end_layout

\begin_layout Subsection
Correttezza di LTL
\end_layout

\begin_layout Standard
Gli assiomi A1, A2, A3, 
\begin_inset Formula $K_{\circ}$
\end_inset

, 
\begin_inset Formula $K_{\square}$
\end_inset

 sono validi su tutti i frame, e quindi portano formule vere a formule vere.
\end_layout

\begin_layout Standard
L'assioma Fun vale solo se la relazione di raggiungibilità a un passo è
 una funzione: infatti se non ho stati raggiungibili da uno stato, abbiamo
 che non vale 
\begin_inset Formula $\circ a$
\end_inset

, e quindi vale 
\begin_inset Formula $\neg\circ a$
\end_inset

, ma 
\begin_inset Formula $\circ\neg a$
\end_inset

 non può valere perché non ci sono stati raggiungibili.
 Mentre se abbiamo più di uno stato raggiungibile 
\begin_inset Formula $\circ a$
\end_inset

 è falso anche se solo in uno degli stati vale 
\begin_inset Formula $\neg a$
\end_inset

, e quindi 
\begin_inset Formula $\circ\neg a$
\end_inset

 non può essere vero, perché 
\begin_inset Formula $\neg a$
\end_inset

 è vero solo in un successore.
 Ma per definizione la raggiungibilità a un passo è una funzione.
\end_layout

\begin_layout Standard
Mix implica immediatamente lo schema T e quindi la riflessività.
\end_layout

\begin_layout Standard
4: 
\begin_inset Formula $\boa\implies\boxx{\boa}$
\end_inset


\end_layout

\begin_layout Standard
Per provare la presenza di 4, notiamo che se vale 
\end_layout

\begin_layout Standard
Mix, vale anche: 
\begin_inset Formula $\boa\implies\circ\boa$
\end_inset

 (se vale l'and vale anche uno solo delle due parti)
\end_layout

\begin_layout Standard
Per 
\begin_inset Formula $RN_{\square}:\boxx{(\boa\implies\circ\boa)}$
\end_inset


\end_layout

\begin_layout Standard
Scrivendo Ind (con 
\begin_inset Formula $\boa$
\end_inset

 come 
\begin_inset Formula $a$
\end_inset

): 
\begin_inset Formula $\boxx{(\boxx{a\implies\circ\boxx a)\implies(\boxx{a\implies\boxx{\boa)}}}}$
\end_inset

 
\end_layout

\begin_layout Standard
Per MP dalle due precedenti: 
\begin_inset Formula $\boa\implies\boxx{\boa}$
\end_inset


\end_layout

\begin_layout Standard
Si può inoltre dimostrare che sono validi gli assiomi:
\end_layout

\begin_layout Standard
\begin_inset Formula $L1:\,\boxx{(\boa\implies b)\vee\boxx{(\boxx b\implies a)}}$
\end_inset

 di cui L è una banale estensione, che indica la debole connessione del
 frame.
\end_layout

\begin_layout Standard
\begin_inset Formula $Dum:\,(\boa\implies a)\implies(\diam{\boa\implies\boa)}$
\end_inset

 che svolge lo stesso ruolo di Z per la relazione 
\begin_inset Formula $\leq$
\end_inset

sul frame 
\begin_inset Formula $\omega$
\end_inset


\end_layout

\begin_layout Subsection
CTL
\end_layout

\begin_layout Standard
In questa logica si cerca di modellizzare l'esecuzione di più programmi
 lanciati in parallelo, e quindi di fatto descrive un frame in cui ogni
 nodo ha al massimo n figli.
\end_layout

\begin_layout Standard
CTL usa i seguenti operatori modali:
\end_layout

\begin_layout Standard
\begin_inset Formula $[\forall F]a$
\end_inset

: su ogni possibile sequenza di stati successivi all’attuale ce n'è uno
 in cui 
\begin_inset Formula $a$
\end_inset

 è vera,
\end_layout

\begin_layout Standard
\begin_inset Formula $[\exists F]a$
\end_inset

: esiste almeno uno stato in una sequenza di stati successivi all’attuale
 in cui 
\begin_inset Formula $a$
\end_inset

 è vera,
\end_layout

\begin_layout Standard
\begin_inset Formula $[\forall G]a$
\end_inset

: a vale in tutti gli stati dell'albero
\end_layout

\begin_layout Standard
\begin_inset Formula $[\exists G]a$
\end_inset

: esiste una sequenza di stati successivi all'attuale tale che 
\begin_inset Formula $a$
\end_inset

 è vero in ogni stato di tale sequenza
\end_layout

\begin_layout Standard
\begin_inset Formula $[\forall X]a$
\end_inset

: in tutte le esecuzioni, nello stato successivo vale a
\end_layout

\begin_layout Standard
\begin_inset Formula $[\exists X]a$
\end_inset

: c'è uno stato successivo in cui vale a
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall(a\mathcal{U}b)$
\end_inset

: in tutti i rami vale 
\begin_inset Formula $a\mathcal{U}b$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\exists(a\mathcal{U}b)$
\end_inset

: in almeno un ramo vale 
\begin_inset Formula $a\mathcal{U}b$
\end_inset


\end_layout

\begin_layout Standard
Tuttavia sono necessari solo tre operatori, mentre tutti gli altri si possono
 ricavare, quelli indispensabili sono:
\end_layout

\begin_layout Standard
\begin_inset Formula $[\forall X]a$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\forall(a\mathcal{U}b)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\exists(a\mathcal{U}b)$
\end_inset


\end_layout

\begin_layout Standard
E infatti si dimostra facilmente che:
\end_layout

\begin_layout Standard
\begin_inset Formula $[\forall F]a\equiv\forall(\top\mathcal{U}a)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $[\exists F]a\equiv\exists(\top\mathcal{U}a)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $[\forall F]a\equiv\neg\exists(\top\mathcal{U\neg}a)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $[\exists F]a\equiv\neg\forall(\top\mathcal{U\neg}a)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $[\exists xX]a\equiv\neg[\forall X]\neg a$
\end_inset


\end_layout

\begin_layout Standard
Si può ora assiomatizzare ctl usando solo gli operatori normali nel seguente
 modo:
\end_layout

\begin_layout Standard
A1, A2, A3, MP
\end_layout

\begin_layout Standard
\begin_inset Formula $K_{\forall x}:\,[\forall X](a\implies b)\implies([\forall X]a\implies[\forall X]b)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D_{\forall x}:\,[\exists X]\top$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\exists U:\,\exists(a\mathcal{U}b)\iff b\vee(a\wedge[\exists X]\exists(a\mathcal{U}b))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\forall U:\,\forall(a\mathcal{U}b)\iff b\vee(a\wedge[\forall X]\forall(a\mathcal{U}b))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $RN_{\forall x}:\,\dfrac{a}{[\forall x]a}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\exists-Ind:\,\dfrac{b\vee(a\wedge[\exists x]c)\implies c}{\exists(a\mathcal{U}b)\implies c}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\forall-Ind:\,\dfrac{b\vee(a\wedge[\forall x]c)\implies c}{\forall(a\mathcal{U}b)\implies c}$
\end_inset


\end_layout

\begin_layout Section
Logica Dinamica
\end_layout

\begin_layout Subsection
Definizione della logica dinamica
\end_layout

\begin_layout Standard
La logica dinamica è una logica che si occupa di descrivere le proprietà
 di un programma.
\end_layout

\begin_layout Standard
L'idea è di associare a ogni istruzione 
\begin_inset Formula $\alpha$
\end_inset

 del programma un operatore modale 
\begin_inset Formula $[\alpha]a$
\end_inset

 con il significato 
\begin_inset Quotes eld
\end_inset

dopo ogni esecuzione di 
\begin_inset Formula $\alpha$
\end_inset

 a è vera
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
L'operatore duale 
\begin_inset Formula $<\alpha>a$
\end_inset

 significa invece 
\begin_inset Quotes eld
\end_inset

esiste una esecuzione di 
\begin_inset Formula $\alpha$
\end_inset

, dopo la quale a è vera
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
quindi vale come al solito:
\end_layout

\begin_layout Standard
\begin_inset Formula $<\alpha>\equiv\neg[\alpha]\neg$
\end_inset


\end_layout

\begin_layout Standard
Le logiche dinamiche si definiscono sul particolare modello:
\end_layout

\begin_layout Standard
\begin_inset Formula $\mu=(S,\,\{R_{\alpha}\,|\,\alpha\in Programmi\},\, V)$
\end_inset


\end_layout

\begin_layout Standard
Definiamo gli insiemi:
\end_layout

\begin_layout Standard
\begin_inset Formula $\phi$
\end_inset

: insieme delle formule atomiche
\end_layout

\begin_layout Standard
\begin_inset Formula $\pi$
\end_inset

: insieme dei programmi elementari
\end_layout

\begin_layout Standard
Le formule ben formate sono definite come al solito:
\end_layout

\begin_layout Itemize
\begin_inset Formula $a\in\phi$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\neg a,\,[\alpha]a,\,<\alpha>a$
\end_inset

 con 
\begin_inset Formula $\alpha$
\end_inset

 programma
\end_layout

\begin_layout Itemize
\begin_inset Formula $a\wedge b,\, a\vee b,\, a\implies b,\, a\iff b$
\end_inset


\end_layout

\begin_layout Itemize
null'altro è una formula ben formata.
\end_layout

\begin_layout Standard
I programmi sono definiti come:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha\in\pi$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha;\beta$
\end_inset

 ossia la concatenazione di due programmi
\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha\cup\beta$
\end_inset

 ossia non-deterministicamente 
\begin_inset Formula $\alpha$
\end_inset

 oppure 
\begin_inset Formula $\beta$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\alpha^{*}$
\end_inset

ossia la ripetizione di 
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $a?$
\end_inset

 ossia il test di 
\begin_inset Formula $\alpha$
\end_inset


\end_layout

\begin_layout Standard
Le relazioni che descrivono il comportamento dei programmi composti sono
 espressi dalle seguenti equivalenze:
\end_layout

\begin_layout Standard
\begin_inset Formula $R_{\alpha;\beta}\equiv R_{\alpha}\circ\, R_{\beta}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R_{\alpha\cup\beta}\equiv R_{\alpha}\cup\, R_{\beta}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R_{\alpha^{*}}\equiv\underset{n\geq0}{\bigcup}R_{\alpha}^{n}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R_{a?}\equiv\{(s,\, s)\,|\,\veraw{\mu}sa\}$
\end_inset


\end_layout

\begin_layout Subsection
Assiomatizzazione della logica dinamica
\end_layout

\begin_layout Standard
La logica dinamica modale può essere assiomatizzata aggiungendo agli schemi
 della logica multimodale normale, ossia gli assiomi A1, A2, A3, 
\begin_inset Formula $K_{[\alpha]}$
\end_inset

 i seguenti assiomi:
\end_layout

\begin_layout Standard
Comp: 
\begin_inset Formula $[\alpha;\beta]a\iff[\alpha][\beta]a$
\end_inset


\end_layout

\begin_layout Standard
Union: 
\begin_inset Formula $[\alpha\cup\beta]a\iff[\alpha]\wedge[\beta]a$
\end_inset

 
\end_layout

\begin_layout Standard
Mix: 
\begin_inset Formula $[\alpha^{*}]a\iff a\wedge[\alpha][\alpha^{*}]a$
\end_inset


\end_layout

\begin_layout Standard
Ind: 
\begin_inset Formula $[\alpha^{*}](a\implies[\alpha]a)\implies(a\implies[\alpha^{*}]a)$
\end_inset


\end_layout

\begin_layout Standard
Test: 
\begin_inset Formula $[a?]b\iff(a\implies b)$
\end_inset


\end_layout

\begin_layout Subsection
Logica dinamica concorrente proposizionale
\end_layout

\begin_layout Standard
Si può estendere la logica dinamica, normalmente utilizzata per programmi
 sequenziali, ai programmi concorrenti, aggiungendo l'operatore 
\begin_inset Formula $[\alpha\cap\beta]a$
\end_inset

 che significa 
\begin_inset Quotes eld
\end_inset

dopo aver eseguito parallelamente 
\begin_inset Formula $\alpha$
\end_inset

 e 
\begin_inset Formula $\beta$
\end_inset

 è vera a
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Per farlo tuttavia, dobbiamo modificare le relazioni del modello, per poter
 gestire i casi con la concorrenza, e quindi abbiamo che:
\end_layout

\begin_layout Standard
\begin_inset Formula $R_{\alpha}\subseteq S\times\mathcal{P}(S)$
\end_inset


\end_layout

\begin_layout Standard
E' quindi necessario cambiare pure la semantica della logica:
\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw{\mu}S{[\alpha]a}\iff\forall T\subseteq S\,:\,(\alpha,\, T)\in R_{\alpha}\,\wedge\,\forall t\in T\,\veraw{\mu}ta$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\veraw{\mu}S{<\alpha>a}\iff\exists T\subseteq S\,:\,(\alpha,\, T)\in R_{\alpha}\,\wedge\,\forall t\in T\,\veraw{\mu}ta$
\end_inset


\end_layout

\begin_layout Standard
Si nota quindi che:
\end_layout

\begin_layout Standard
\begin_inset Formula $[\alpha]\not\equiv\neg<\alpha>\neg$
\end_inset


\end_layout

\begin_layout Standard
Allora è necessario ridefinire il prodotto tra relazioni:
\end_layout

\begin_layout Standard
\begin_inset Formula $(s,\, T)\in R_{\alpha}\circ\, R_{\beta}\iff\exists U\subseteq\mathcal{P}(S)\,\wedge\,(s,\, U)\in R_{\alpha}\,\wedge\,\forall u\in U\exists T_{u}\,:\,(u,\, T_{u})\in R_{\beta}\,\wedge\, T=\underset{u\in U}{\bigcup T_{u}}$
\end_inset


\end_layout

\begin_layout Standard
Il prodotto di relazioni è quindi cambiato, passando dal seguente grafo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\backslash
begin{tikzpicture}[scale=0.2] 
\backslash
tikzstyle{every node}+=[inner sep=0pt] 
\backslash
draw [black] (21.4,-15.1) circle (3); 
\backslash
draw (21.4,-15.1) node {$s$}; 
\backslash
draw [black] (37.5,-15.1) circle (3); 
\backslash
draw (37.5,-15.1) node {$u$}; 
\backslash
draw [black] (53.8,-15.1) circle (3); 
\backslash
draw (53.8,-15.1) node {$t$}; 
\backslash
draw [black] (23.492,-12.966) arc (126.89872:53.10128:9.923); 
\backslash
fill [black] (35.41,-12.97) -- (35.07,-12.09) -- (34.47,-12.89); 
\backslash
draw (29.45,-10.48) node [above] {$R_
\backslash
alpha$}; 
\backslash
draw [black] (39.613,-12.986) arc (126.52967:53.47033:10.141); 
\backslash
fill [black] (51.69,-12.99) -- (51.34,-12.11) -- (50.75,-12.91); 
\backslash
draw (45.65,-10.49) node [above] {$R_
\backslash
beta$}; 
\backslash
end{tikzpicture} 
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Al seguente grafo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
definecolor{cffffff}{RGB}{255,255,255}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[y=0.80pt,x=0.80pt,yscale=-1, inner sep=0pt, outer sep=0pt]
   
\backslash
path[cm={{0.58805,0.0,0.0,0.68269,(24.31388,102.98422)}},draw=black,fill=cffffff]
     (156.7931,87.4161)arc(0.000:180.000:50.387171 and     44.750)arc(-180.000:0.000:50.3
87171 and 44.750) -- cycle;   
\backslash
path[fill=black] (82.20771,167.96637) node[above right] (text3755) {s};  
 
\backslash
path[cm={{0.74795,0.0,0.0,0.85608,(68.60394,12.42678)}},draw=black,fill=cffffff]
     (265.1861,106.6421)arc(0.000:180.000:73.920640 and     42.098)arc(-180.000:0.000:73.
920640 and 42.098) -- cycle;   
\backslash
path[fill=black] (180.73416,65.26226) node[above right] (text3763) {U};  
 
\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.800pt]     (110.0523,14
5.4256) -- (164.8679,122.9266);   
\backslash
path[cm={{0.71337,0.0,0.0,0.47229,(79.07095,130.99431)}},draw=black,fill=cffffff]
     (265.1861,106.6421)arc(0.000:180.000:73.920640 and     42.098)arc(-180.000:0.000:73.
920640 and 42.098) -- cycle;   
\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.800pt]     (113.3671,17
4.5960) -- (163.5672,177.9203);   
\backslash
path[shift={(-12.0,0)},draw=black,fill=cffffff]     (236.0157,85.7587)arc(-0.038:180.
038:13.922)arc(-180.038:0.038:13.922) --     cycle;   
\backslash
path[cm={{0.92174,0.0,0.0,0.92174,(-3.13845,9.35718)}},draw=black,fill=cffffff]
     (245.2972,119.5699)arc(-0.021:180.021:14.916721 and     12.596)arc(-180.021:0.021:1
4.916721 and 12.596) -- cycle;   
\backslash
path[fill=black] (200,89.362183) node[above right] (text3817) {u1};   
\backslash
path[fill=black] (200.91348,124.35682) node[above right] (text3817-5) {u2};
   
\backslash
path[fill=black] (124.37474,126.52254) node[above right] (text3842) {$R_
\backslash
alpha$};   
\backslash
path[fill=black] (127.6106,171.96516) node[above right] (text3846) {$R_
\backslash
alpha$};   
\backslash
path[cm={{0.8212,0.0,0.0,0.49268,(188.32152,21.20068)}},draw=black,fill=cffffff]
     (265.1861,106.6421)arc(0.000:180.000:73.920640 and     42.098)arc(-180.000:0.000:73.
920640 and 42.098) -- cycle;   
\backslash
path[cm={{0.8212,0.0,0.0,0.42066,(180.68016,98.39161)}},draw=black,fill=cffffff]
     (265.1861,106.6421)arc(0.000:180.000:73.920640 and     42.098)arc(-180.000:0.000:73.
920640 and 42.098) -- cycle;   
\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.800pt]     (222.6493,12
2.0455) -- (286.4164,133.7944);   
\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.723pt]     (221.3768,77.
3255) -- (285.5725,77.2936);   
\backslash
path[shift={(99.17758,-11.35244)},draw=black,fill=cffffff]     (236.0157,85.7587)arc
(-0.038:180.038:13.922)arc(-180.038:0.038:13.922) --     cycle;   
\backslash
path[cm={{0.92174,0.0,0.0,0.92174,(102.03913,32.00475)}},draw=black,fill=cffffff]
     (245.2972,119.5699)arc(-0.021:180.021:14.916721 and     12.596)arc(-180.021:0.021:1
4.916721 and 12.596) -- cycle;   
\backslash
path[fill=black] (315.17758,78.00975) node[above right] (text3817-0) {t1};
   
\backslash
path[fill=black] (306.09106,147.00439) node[above right] (text3817-5-7) {t3};
   
\backslash
path[shift={(139.67676,-10.5883)},draw=black,fill=cffffff]     (236.0157,85.7587)arc
(-0.038:180.038:13.922)arc(-180.038:0.038:13.922) --     cycle;   
\backslash
path[cm={{0.92174,0.0,0.0,0.92174,(142.53831,32.76888)}},draw=black,fill=cffffff]
     (245.2972,119.5699)arc(-0.021:180.021:14.916721 and     12.596)arc(-180.021:0.021:1
4.916721 and 12.596) -- cycle;   
\backslash
path[fill=black] (353.67676,78.773872) node[above right] (text3817-6) {t2};
   
\backslash
path[fill=black] (346.59024,147.76852) node[above right] (text3817-5-6) {t4};
   
\backslash
path[fill=black] (326.2858,46.646969) node[above right] (text3942) {T1}; 
  
\backslash
path[fill=black] (324.32019,122.09327) node[above right] (text3942-3) {T2};
   
\backslash
path[fill=black] (248.34399,146.86179) node[above right] (text3990) {$R_
\backslash
beta$};   
\backslash
path[fill=black] (253.16176,74.356461) node[above right] (text3990-7) {$R_
\backslash
beta$};   
\backslash
path[fill=black,line join=miter,line cap=butt,line width=0.800pt] (0,0) 
    node[above right] (flowRoot4015) {};   
\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.800pt]     (401.1048,36.
8263) ..
 controls (409.7612,32.3735) and (435.8124,31.6775) ..
     (440.0757,44.4676) ..
 controls (444.4570,57.6116) and (438.5475,69.8092) ..
     (438.5475,84.2027) ..
 controls (438.5475,89.4537) and (452.1943,92.7158) ..
     (448.4812,96.4288) ..
 controls (445.2189,99.6911) and (435.7460,104.0714) ..
     (438.5475,112.4757) ..
 controls (442.6528,124.7916) and (450.2611,160.1129) ..
     (443.8964,172.8424) ..
 controls (440.9921,178.6510) and (417.3816,176.6631) ..
     (411.0386,176.6631);   
\backslash
path[fill=black] (462.52805,101.66471) node[above right] (text4174) {T};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Bisogna cambiare anche la Relazione di iterazione nel seguente modo:
\end_layout

\begin_layout Standard
\begin_inset Formula $R_{\alpha^{*}}\equiv\underset{n\geq0}{\bigcup}R_{\alpha}^{n}$
\end_inset

 con 
\begin_inset Formula $R_{\alpha}^{0}=\{(s,\,\{s\})\,|\, s\in S\}$
\end_inset

 e 
\begin_inset Formula $R_{\alpha}^{n}=R_{\alpha}\circ\, R_{\alpha}^{n-1}$
\end_inset

 
\end_layout

\begin_layout Standard
Inoltre si introduce la relazione di combinazione, ossia quella che traduce
 il parallelismo (l'operatore intersezione):
\end_layout

\begin_layout Standard
\begin_inset Formula $(s,\, T)\in R_{\alpha}\otimes R_{\beta}\iff T=U\cup V\,\wedge\,(s,U)\in R_{\alpha}\,\wedge\,(s,V)\in R_{\beta}$
\end_inset


\end_layout

\begin_layout Standard
Tutto il resto è definito allo stesso modo di prima, a meno di stare attenti
 agli insiemi di stati, anziché agli stati.
\end_layout

\end_body
\end_document
