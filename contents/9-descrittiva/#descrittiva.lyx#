#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble


\title{Logica e Algebra 2}

\usepackage[english]{babel}
\usepackage{tikz}

\usepackage{settings/usefulMacros} 

\usepackage{booktabs}\usepackage{listings}\lstset{columns=fullflexible}

\usepackage{wasysym}

\usepackage{amsthm}\newtheoremstyle{note} % name
{\topsep} 	% Space above
{\topsep} 	% Space below
{\small}		% Body font
{}		% Indent amount
{\small\bfseries}% Theorem head font
{:}		% Punctuation after theorem head
{.5em}	% Space after theorem head
{}		% Theorem head spec (can be left empty, meaning ‘normal’)

\usepackage{fancyhdr}%% Cambia il carattere delle didascalie delle figure %%
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}

\usepackage{comment}

%per le tabelle lunghe e particolari
\usepackage{lscape}



\usepackage{babel}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding utf8
\fontencoding T1
\font_roman default
\font_sans default
\font_typewriter mathpazo
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 2
\use_esint 1
\use_mhchem 0
\use_mathdots 0
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{savequote}[50mm]
\end_layout

\begin_layout Plain Layout

---Non so spiegarlo chiaramente, perchè non è chiaro neanche a me---
\end_layout

\begin_layout Plain Layout


\backslash
qauthor{Alice} 
\backslash
end{savequote}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Logiche Descrittive	
\end_layout

\begin_layout Section
Introduzione - Logica 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 
\end_layout

\begin_layout Standard
Le DL sono una famiglia di logiche per la rappresentazione della conoscenza
 che possono essere utilizzate per rappresentare conoscenza terminologica,
 dando ad essa una semantica formale ben definita.
\end_layout

\begin_layout Standard
Un sistema di rappresentazione della conoscenza (KR) fornisce i mezzi per
 definire, gestire, manipolare e ragionare su basi di conoscenza (KB).
\end_layout

\begin_layout Standard
In una KB ci sono T-Box e A-Box
\end_layout

\begin_layout Standard
I TBox descrivono la terminologia della KB (concetti, ruoli atomici e concetti
 composti), gli ABox sono asserzioni su individui della KB
\end_layout

\begin_layout Standard
TBox es.
 
\begin_inset Formula $Madre\equiv Donna\sqcap Genitore$
\end_inset


\end_layout

\begin_layout Standard
ABox es.
 
\begin_inset Formula $Donna(Paola)$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La famiglia di logiche descrittive più utilizzata è la famiglia 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 (Attributive Language).
\end_layout

\begin_layout Standard
Nella logica 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 (logica descrittiva tra le più semplici) ci sono:
\end_layout

\begin_layout Description
A,B,C concetti
\end_layout

\begin_layout Description
R ruoli
\end_layout

\begin_layout Description
		
\begin_inset Formula $\neg$
\end_inset

 simazione (solo di concetti atomici)
\end_layout

\begin_layout Description
\begin_inset Formula $\sqcap$
\end_inset

 di concetti
\end_layout

\begin_layout Description

\series medium
I concetti sono:
\end_layout

\begin_layout Itemize
Concetti atomici A,B
\end_layout

\begin_layout Itemize
\begin_inset Formula $\top$
\end_inset

, 
\begin_inset Formula $\bot$
\end_inset


\end_layout

\begin_layout Itemize
simazione di concetti atomici: 
\begin_inset Formula $\neg A$
\end_inset


\end_layout

\begin_layout Itemize
and di concetti: 
\begin_inset Formula $C\sqcap D$
\end_inset


\end_layout

\begin_layout Itemize
quantificazioni: 
\begin_inset Formula $\forall R.C$
\end_inset

, 
\begin_inset Formula $\exists R.\top$
\end_inset


\end_layout

\begin_layout Standard
Un'interpretazione I di una base di conoscenza è una coppia 
\begin_inset Formula $I=<\Delta^{I},\ ·^{I}>$
\end_inset

 composta da un dominio di interpretazione 
\begin_inset Formula $\Delta$
\end_inset

I, detto dominio di I e da una funzione di interpretazione 
\begin_inset Formula $·^{I}$
\end_inset

 che associa:
\end_layout

\begin_layout Standard
ad ogni 
\series bold
nome
\series default
 di individuo un elemento: 
\end_layout

\begin_layout Standard
\begin_inset Formula $a^{I}\in\Delta^{I}$
\end_inset


\end_layout

\begin_layout Standard
ad ogni 
\series bold
concetto
\series default
 C un sottoinsieme di 
\begin_inset Formula $\Delta^{I}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I:\ C\rightarrow C^{I}\subseteq\Delta^{I}$
\end_inset


\end_layout

\begin_layout Standard
e ad ogni 
\series bold
ruolo
\series default
 un sottoinsieme di 
\begin_inset Formula $\Delta$
\end_inset

I × 
\begin_inset Formula $\Delta$
\end_inset

I :
\end_layout

\begin_layout Standard
\begin_inset Formula $I:\ R\rightarrow R^{I}\subseteq\Delta^{I}\times\Delta^{I}$
\end_inset


\end_layout

\begin_layout Standard
I rouli sono quindi relazioni binarie, una volta interpretati
\end_layout

\begin_layout Standard
es.
 
\begin_inset Formula $(Peter,\ Chris)^{I}\in HaFiglio^{I}$
\end_inset


\end_layout

\begin_layout Standard
		
\end_layout

\begin_layout Standard
Inoltre:
\end_layout

\begin_layout Standard
\begin_inset Formula $\bot^{I}=\emptyset$
\end_inset

, 
\begin_inset Formula $\top^{I}=\Delta^{I}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $(C\sqcap D)^{I}=C^{I}\cap D^{I}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $(\forall R.C)^{I}=\{a^{I}\in\Delta^{I}:\ (a^{I},b^{I})\in R^{I}\implies b^{I}\in C^{I}$
\end_inset

} 
\end_layout

\begin_layout Standard
es.
 
\begin_inset Formula $\forall Possiede.Cosa$
\end_inset

 cioè se a possiede un oggetto del dominio quello deve essere una cosa (slavery
 is bad)
\end_layout

\begin_layout Standard
\begin_inset Formula $(\exists R.C)^{I}=\{a^{I}\in\Delta^{I}:\ \exists b\in\Delta^{I}:\ (a^{I},b^{I})\in R^{I}\wedge b^{I}\in C^{I}\}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
es.
 
\begin_inset Formula $\exists HaFiglio.Femmina$
\end_inset

 cioè l'insieme dei genitori con una figlia femmina
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection
Varianti di 
\begin_inset Formula $\mathcal{AL}$
\end_inset


\end_layout

\begin_layout Standard
Indebolendo la logica 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 si ottengono le logiche poco descrittive della famiglia 
\begin_inset Formula $\mathcal{FL}$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{FL}$
\end_inset

- è ottenuta da 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 eliminando la simazione atomica 
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{FL}_{0}$
\end_inset

 è ottenuta da 
\begin_inset Formula $\mathcal{FL}$
\end_inset

- eliminando anche la quantificazione esistenziale
\end_layout

\begin_layout Standard
La logica 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 può essere estesa aggiungendo alcuni costruttori: 
\end_layout

\begin_layout Itemize
costrutto 
\begin_inset Formula $\mathcal{U}$
\end_inset

 disgiunzione dei concetti 
\begin_inset Formula $C\sqcup D$
\end_inset


\end_layout

\begin_layout Itemize
costrutto 
\begin_inset Formula $\mathcal{E}$
\end_inset

 quantificazione esistenziale qualificata 
\begin_inset Formula $\exists R.C$
\end_inset


\end_layout

\begin_layout Itemize
costrutto 
\begin_inset Formula $\mathcal{C}$
\end_inset

 complemento di concetti complessi 
\begin_inset Formula $\neg C$
\end_inset


\end_layout

\begin_layout Itemize
costrutto 
\begin_inset Formula $\mathcal{N}$
\end_inset

 cardinalità di un ruolo 
\end_layout

\begin_layout Standard
\begin_inset Formula $(\leq nR)^{I}=\{a^{I}:\ \cardinal{\{b^{I}:\ (a^{I},b^{I})\in R^{I}\}}<n\}$
\end_inset


\end_layout

\begin_layout Standard
es.
 
\begin_inset Formula $(\leq2HaFiglio)^{I}$
\end_inset

 è l'insieme delle persone un numero di figli minore o uguale a 2.
\end_layout

\begin_layout Section
Confronti fra logiche 
\end_layout

\begin_layout Standard
In modo analogo a quanto si era fatto con le logiche derivate da K, denotiamo
 con ALX la logica AL a cui si aggiunge il costrutto X
\end_layout

\begin_layout Subsection
Equivalenza 
\begin_inset Formula $\alue$
\end_inset

ed 
\begin_inset Formula $\mathcal{ALC}$
\end_inset


\end_layout

\begin_layout Standard
Dimostriamo che 
\begin_inset Formula $\mathcal{AL}\mathcal{UE}\equiv\mathcal{AL}\mathcal{C}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
IP) 
\begin_inset Formula $\mathcal{UE}$
\end_inset


\end_layout

\begin_layout Standard
Ts)
\begin_inset Formula $\mathcal{C}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Si vuole mostrate che a partire in
\begin_inset Formula $\mathcal{AL}\mathcal{UE}$
\end_inset

 posso fare tutto ciò che faccio in 
\begin_inset Formula $\mathcal{AL}\mathcal{C}$
\end_inset

, il che si riduce a mostrare che in 
\begin_inset Formula $\alue$
\end_inset

posso fare simazioni di concetti qualsiasi.
\end_layout

\begin_layout Standard
Questo è immediato per i concetti atomici la cui simazione è per definizione
 in 
\begin_inset Formula $\mathcal{AL}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\neg\top\equiv\bot$
\end_inset

, 
\begin_inset Formula $\neg\bot\equiv\top$
\end_inset


\end_layout

\begin_layout Standard
Per simare l'and di due concetti:
\end_layout

\begin_layout Standard
\begin_inset Formula $\neg(D\sqcap E)\equiv\neg D\sqcup\neg E$
\end_inset

 che sono concetti più semplici di cui ricorsivamente posso costruire la
 simazione
\end_layout

\begin_layout Standard
\begin_inset Formula $\neg\forall R.C\equiv\exists R.\neg C$
\end_inset


\end_layout

\begin_layout Standard
Con queste semplici trasformazioni posso rendere ricorsivamente più semplice
 una qualsiasi formula di 
\begin_inset Formula $\alc$
\end_inset

 fino a portarla in una formula di 
\begin_inset Formula $\alue$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

IP) 
\begin_inset Formula $\mathcal{C}$
\end_inset


\end_layout

\begin_layout Standard
Ts)
\begin_inset Formula $\mathcal{UE}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Sfruttando De Morgan possiamo scrivere:
\end_layout

\begin_layout Standard
\begin_inset Formula $D\sqcup E\equiv\neg(\neg D\sqcap\neg E)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\exists R.C\equiv\neg(\forall R.\neg C)$
\end_inset


\end_layout

\begin_layout Subsection
Confronto con logica del prim'ordine
\end_layout

\begin_layout Standard
È possibile vedere le logiche 
\begin_inset Formula $\mathcal{AL\mbox{,}ALC\mbox{,}ALN}$
\end_inset

 come casi particolari di una logica del prim ordine(deve essere con identità
 nel caso di 
\begin_inset Formula $\mathcal{N}$
\end_inset

).
\end_layout

\begin_layout Itemize
A è un concetto: 
\begin_inset Formula $a(x)$
\end_inset


\end_layout

\begin_layout Itemize
R è un ruolo: 
\begin_inset Formula $R(x,y)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $a\ $
\end_inset

è un individuo: 
\begin_inset Formula $a$
\end_inset

 è una costante
\end_layout

\begin_layout Standard
Notiamo che ci sono due sole variabili libere e il dominio è fissato (controllar
e) la logica del prim'ordine è decidibile.
\end_layout

\begin_layout Description
\begin_inset Formula $\neg C$
\end_inset

: 
\begin_inset Formula $\neg C(x)$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $C\sqcap D\mathbf{:}$
\end_inset

 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $C(x)\wedge D(x)$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\forall R.C$
\end_inset

: 
\begin_inset Formula $\forall y:(R(x,y)\implies C(y)$
\end_inset

)
\end_layout

\begin_layout Description
\begin_inset Formula $\exists R.C:$
\end_inset

 
\begin_inset Formula $\exists y:(R(x,y)\implies C(y))$
\end_inset


\end_layout

\begin_layout Description
\begin_inset Formula $\leq nR$
\end_inset


\begin_inset Formula $,$
\end_inset

 la logica deve essere con unità cioè avere un predicato di uguaglianza
 E
\end_layout

\begin_layout Description
\begin_inset Formula $\exists x_{1},\ x_{2},...,\ x_{n+1}(R(x,x_{1})\wedge R(x,x_{2})\wedge\dots R(x,x_{n})$
\end_inset

 
\end_layout

\begin_layout Description
\begin_inset Formula $\implies E(x_{1},x_{2})\vee E(x_{1},x_{2})\vee\dots..\underset{1\leq i\leq j\leq n+1}{\bigvee}E(x_{i},x_{j})$
\end_inset


\end_layout

\begin_layout Section
Terminologia
\end_layout

\begin_layout Itemize
Definizione: 
\end_layout

\begin_layout Standard
Una definizione associa a un concetto atomico un concetto complesso (non
 atomico) es.
 
\begin_inset Formula $Parent\equiv Father\sqcup Mather$
\end_inset

, il concetto atomico viene detto anche simbolo nominale
\end_layout

\begin_layout Itemize
Simbolo di base (o nominale):
\end_layout

\begin_layout Standard
I ruoli e i concetti che appaiono solo nelle parti destre delle definizioni
\end_layout

\begin_layout Itemize
Interpretazione di base:
\end_layout

\begin_layout Standard
Un'interpretazione di una T-Box che interpreta solo i simboli di base
\end_layout

\begin_layout Itemize
Aciclico:
\end_layout

\begin_layout Standard
Nessun simbolo nominale usa sé stesso
\end_layout

\begin_layout Itemize
T-Box definitorio:
\end_layout

\begin_layout Standard
La sua interpretazione si estende in modo unico a una interpretazione di
 tutto il t-box (estesa)
\end_layout

\begin_layout Standard
Un T-Box è definitorio se è possibile costruirne uno equivalente ma aciclico
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Non sono definitorie alcune T cicliche es.
\end_layout

\begin_layout Standard
\begin_inset Formula $Human\equiv Animal\sqcap\forall hasParent.Human$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Ma alcune T cicliche sono definitorie es.
\end_layout

\begin_layout Standard
\begin_inset Formula $A\equiv B\sqcap\exists R.(A\sqcap\neg A)$
\end_inset

 che è equivalente a:
\end_layout

\begin_layout Standard
\begin_inset Formula $A\equiv B\sqcap\exists R.(\bot)$
\end_inset

 
\end_layout

\begin_layout Section
Terminologia generalizzata
\end_layout

\begin_layout Standard
A volte è possibile aggiungere nuovi operatori qua descritti.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Inclusione
\end_layout

\begin_layout Standard
Si possono usare T-Box del tipo:
\end_layout

\begin_layout Standard
\begin_inset Formula $A\sqsubseteq B$
\end_inset

 che vale se e solo se 
\begin_inset Formula $A^{I}\subseteq B^{I}$
\end_inset


\end_layout

\begin_layout Standard
Una terminologia T generalizzata (cioè che contiene assiomi di inclusione)
 può essere tradotta in una forma T normalizzata sostituendo le forme del
 tipo:
\end_layout

\begin_layout Standard
\begin_inset Formula $Woman\sqsubseteq Person$
\end_inset

 con 
\begin_inset Formula $Woman\mbox{\equiv}\underline{Woman}\sqcap Person$
\end_inset

 dove 
\begin_inset Formula $\underline{Woman}$
\end_inset

 è un nuovo simbolo base (che denota qualità specifiche)
\end_layout

\begin_layout Standard
In termini di espressività, le due forme sono equivalenti
\end_layout

\begin_layout Standard
Ogni modello di 
\begin_inset Formula $T$
\end_inset

 è anche modello di 
\begin_inset Formula $\underline{T}$
\end_inset


\end_layout

\begin_layout Standard
Qualsiasi interpretazione base di un modello di 
\begin_inset Formula $T$
\end_inset

 è anche interpretazione base di un modello di 
\begin_inset Formula $\underline{T}$
\end_inset


\end_layout

\begin_layout Standard
Così facendo si ha che: 
\begin_inset Formula $Woman^{I}\subseteq Person^{I}$
\end_inset

 e quindi 
\begin_inset Formula $Woman^{I}\equiv Person\cap(\underline{Woman})^{I}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Set
\end_layout

\begin_layout Standard
\begin_inset Formula $Set\ \{a_{1},a_{2},\dots,a_{n}^{I}\}=\{a_{1}^{I},a_{2}^{I},\dots,a_{n}^{I}\}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Fills
\end_layout

\begin_layout Standard
\begin_inset Formula $Fills\ r\ c$
\end_inset

 sono gli individui che sono in relazione tramite 
\begin_inset Formula $r$
\end_inset

 agli individui identificati da 
\begin_inset Formula $c$
\end_inset


\end_layout

\begin_layout Standard
es.
 
\begin_inset Formula $FILLS\ :\ Child\ Chris$
\end_inset

 sono tutti gli individui con figlio 
\begin_inset Quotes eld
\end_inset

Chris
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $(Fills\ R:a)^{I}=\{b\in\Delta^{I}\;:\ (a^{I},b^{I})\in R^{I}\}$
\end_inset


\end_layout

\begin_layout Subsection
Note
\end_layout

\begin_layout Standard
\begin_inset Formula $\exists R.C$
\end_inset

 si può sostituire con 
\begin_inset Formula $\exists R.Set(a)$
\end_inset


\end_layout

\begin_layout Standard
Posso pensare i T-Box come composti solo di definizioni
\end_layout

\begin_layout Standard
Il T-Box può essere tolto del tutto specificando completamente le definizioni
 nell'A-Box
\end_layout

\begin_layout Standard
Normalmente nelle Logiche Descrittive si fa l'UNA: l'unicity name assunction
 cioè si assume che se si usano due nomi come a, b, allora 
\begin_inset Formula $a^{I}\neq b^{I}$
\end_inset


\end_layout

\begin_layout Section
Servizi di Reasoning
\end_layout

\begin_layout Standard
I servizi di reasoning si propongono di risolvono quattro tipi di problemi
\end_layout

\begin_layout Standard

\series bold
Soddifisfacibilità: 
\series default
Un concetto C si dice soddisfacibile rispetto al T-Box T se esiste un modello
 di T tale che 
\begin_inset Formula $C^{I}$
\end_inset

 non è vuoto
\end_layout

\begin_layout Standard

\series bold
Sussunzione: 
\series default
Un concetto C è sussunto da un concetto D, in T se 
\begin_inset Formula $C^{I}\subseteq D^{I}$
\end_inset

 per ogni modello di T
\end_layout

\begin_layout Standard

\series bold
Equivalenze: 
\series default
Due concetti C e D si dicono equivalenti rispetto a T se 
\begin_inset Formula $C^{I}=D^{I}$
\end_inset

per ogni modello di T
\end_layout

\begin_layout Standard

\series bold
Disgiunzione: 
\series default
Due concetti C e D sono disgiunti rispetto a T se 
\begin_inset Formula $C^{I}\cap D^{I}=\emptyset$
\end_inset

 per ogni modello di T
\end_layout

\begin_layout Standard
Mostriamo che una KB che fornisce il servizio di sussunzione risolve anche
 gli altri tre problemi, infatti:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C$
\end_inset

 è insoddisfacibile se e solo se 
\begin_inset Formula $\bot\sqsubseteq C$
\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Formula $C,D$
\end_inset

 sono equivalenti se 
\begin_inset Formula $C\sqsubseteq D$
\end_inset

 e 
\begin_inset Formula $D\sqsubseteq C$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C,D$
\end_inset

 sono disgiunti se 
\begin_inset Formula $C\sqcap D\sqsubseteq\bot$
\end_inset


\end_layout

\begin_layout Section
Feauture Logic
\end_layout

\begin_layout Standard
Le logiche descrittive più semplici appartengono alla famiglia della features
 logics (
\begin_inset Formula $\mathcal{FL}$
\end_inset

 in breve) e sono ottenute indebolendo la più famosa logica 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 inibendo i costruttori di concetto più complessi.
\end_layout

\begin_layout Standard
La più semplice di queste è 
\begin_inset Formula $\mathcal{FL_{\mbox{0}}}$
\end_inset

 che si ottiene da 
\begin_inset Formula $\mathcal{AL}$
\end_inset

 togliendo 
\begin_inset Formula $\bot$
\end_inset

 e 
\begin_inset Formula $\exists$
\end_inset


\end_layout

\begin_layout Standard
Un concetto in 
\series bold
forma normale 
\series default
è del tipo:
\end_layout

\begin_layout Standard
\begin_inset Formula $A_{1}\sqcap A_{2}\sqcap\dots\sqcap A_{n}\sqcap\forall R_{1}.C_{1}\sqcap\forall R_{2}.C_{2}\dots\sqcap\forall R_{m}.C_{m}$
\end_inset


\end_layout

\begin_layout Standard
dove 
\begin_inset Formula $C_{j}$
\end_inset

 sono concetti in forma normale e 
\begin_inset Formula $R_{j}$
\end_inset

 sono ruoli atomici
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Posso scrivere qualsiasi concetto in questo modo con l'accortezza di:
\end_layout

\begin_layout Standard
togliere i duplicati: 
\begin_inset Formula $A_{i}\neq A_{j}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

sciogliere
\begin_inset Quotes erd
\end_inset

 i ruoli con intersezioni: 
\end_layout

\begin_layout Standard
\begin_inset Formula $\forall R.(C\sqcap D)\equiv\forall R.C\sqcap\forall R.D$
\end_inset


\end_layout

\begin_layout Standard
	
\end_layout

\begin_layout Standard
Siano C e D due concetti 
\begin_inset Formula $FL_{0}$
\end_inset

 in forma normale: 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C\equiv A_{1}\sqcap\dots\sqcap A_{m}\sqcap\forall R_{1}.C_{1}\sqcap\forall R_{n}.C_{n}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D\equiv B_{1}\sqcap\dots\sqcap B_{k}\sqcap\forall S_{1}.D_{1}\sqcap\forall S_{l}.D_{l}$
\end_inset

	
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
allora 
\begin_inset Formula $C\sqsubseteq D$
\end_inset

 se e solo se 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
1.
 per ogni i, 
\begin_inset Formula $1\leq i\leq k$
\end_inset

 esiste un j, 
\begin_inset Formula $1\leq j\leq m$
\end_inset

 per il quale 
\begin_inset Formula $B_{i}=A_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
2.
 per ogni i, 
\begin_inset Formula $1\leq i\leq l$
\end_inset

 esiste un j, 
\begin_inset Formula $1\leq j\leq n$
\end_inset

 per il quale 
\begin_inset Formula $S_{i}=R_{j}$
\end_inset

 e 
\begin_inset Formula $C_{j}\sqsubseteq D_{i}$
\end_inset

.
\end_layout

\begin_layout Subsection
Varianti
\end_layout

\begin_layout Standard
Ad 
\begin_inset Formula $\mathcal{AL}_{0}$
\end_inset

 può essere aggiunto il concetto 
\begin_inset Formula $\bot$
\end_inset

, ottenendo 
\begin_inset Formula $\mathcal{AL_{\bot}}$
\end_inset

 e la forma normale viene a essere la stessa di prima a cui si aggiunge
 l'opportunità per un concetto di essere o
\begin_inset Formula $\bot$
\end_inset


\end_layout

\begin_layout Standard
Notiamo che 
\begin_inset Formula $\bot\sqsubseteq C$
\end_inset

, per ogni 
\begin_inset Formula $C$
\end_inset


\end_layout

\begin_layout Standard
Ad 
\begin_inset Formula $AL_{0}$
\end_inset

 si può aggiungere la simazione di concetti atomici ottenendo 
\begin_inset Formula $\mathcal{AL}_{\neg}$
\end_inset


\end_layout

\begin_layout Standard
Notiamo che 
\begin_inset Formula $\bot\equiv A\wedge\neg A$
\end_inset

, quindi 
\begin_inset Formula $\mathcal{AL_{\neg}}$
\end_inset

 contiene strettamente
\begin_inset Formula $\mathcal{AL_{\mbox{0}}}$
\end_inset

	
\end_layout

\begin_layout Standard
In 
\begin_inset Formula $ALC$
\end_inset

 per verificare se 
\begin_inset Formula $C\sqsubseteq D$
\end_inset

 possiamo controllare che 
\begin_inset Formula $C\sqcap\neg D$
\end_inset

 sia insoddisfacibile
\end_layout

\begin_layout Standard
Per controllare 
\begin_inset Formula $C\equiv D$
\end_inset

 possiamo quindi testare 
\begin_inset Formula $C\sqcap\neg D$
\end_inset

 e 
\begin_inset Formula $D\sqcap\neg C$
\end_inset

.
\end_layout

\begin_layout Section
A-Box Reasoning			
\end_layout

\begin_layout Standard
	I servizi di reasoning di A-Box sono:
\end_layout

\begin_layout Standard

\series bold
Consistenza
\series default
: Un A-Box è consistente in un modello T-Box T se c'è un'interpreatzione
 che sia modello sia di T che di A
\end_layout

\begin_layout Standard

\series bold
Instance Checking
\series default
: Un individuo è istanza di un concetto C rispetto a un A-Box A se è membro
 dell'insieme C.
 
\begin_inset Formula $\vera A{C(a)}$
\end_inset

 il che vale se e solo se 
\begin_inset Formula $A\cup\{\neg C(a)\}$
\end_inset

 è insoddisfacibile
\end_layout

\begin_layout Standard

\series bold
Instance Retrivial
\series default
: Trova tutti gli individui che sono istanze di una data descrizione
\end_layout

\begin_layout Standard

\series bold
Problema di Realizzazione
\series default
: Trova il concetto più specifico a cui un individuo appartiene
\end_layout

\begin_layout Subsection
Variante
\end_layout

\begin_layout Standard
T-Box ed A-Box si possono arricchire con 
\begin_inset Formula $C\implies D$
\end_inset

 cioè: per ogni individuo 
\begin_inset Formula $a$
\end_inset

 cui è noto 
\begin_inset Formula $C(a)$
\end_inset

 si ha anche 
\begin_inset Formula $D(a)$
\end_inset

.
\end_layout

\begin_layout Standard
Notiamo che NON vale 
\begin_inset Formula $\neg D\implies\neg C$
\end_inset


\end_layout

\begin_layout Standard
		Tableaux per 
\begin_inset Formula $\alc$
\end_inset


\end_layout

\begin_layout Section
Tableaux per 
\begin_inset Formula $\alc$
\end_inset


\end_layout

\begin_layout Subsection
\begin_inset Formula $\alc\approx K_{n}$
\end_inset


\end_layout

\begin_layout Standard
Si può notare che 
\begin_inset Formula $\alc$
\end_inset

 è equivalente a una logica multimodale con n operatori modali, uno per
 ogni ruolo usato nelle formule considerate:
\end_layout

\begin_layout Standard
\begin_inset Formula $C\sqcap D\longrightarrow C\wedge D$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C\sqcup D\longrightarrow C\vee D$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\neg C\longrightarrow\neg C$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\exists R.C\longrightarrow<R>C$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\forall R.C\longrightarrow[R]C$
\end_inset


\end_layout

\begin_layout Standard
Quindi si potrà usare l'algoritmo dei tableaux per 
\begin_inset Formula $K_{n}$
\end_inset

 anche per 
\begin_inset Formula $\alc$
\end_inset


\end_layout

\begin_layout Subsection
Forma normale simata
\end_layout

\begin_layout Standard
Definiamo la forma nrmale simata di una formula, una formula equivalente
 a quella di partenza ma in cui le simazioni sono spostate solo sui concetti
 atomici (possiamo sempre farlo, vista l'equivalenza tra 
\begin_inset Formula $\alc$
\end_inset

 e 
\begin_inset Formula $\alue$
\end_inset

).
\end_layout

\begin_layout Standard
Se C è in forma normale simata scriviamo NNF(C).
\end_layout

\begin_layout Standard
se C è in forma normale simata, allora 
\begin_inset Formula $\neg C$
\end_inset

 non è in forma normale simata.
 Definiamo allora 
\begin_inset Formula $\sim C$
\end_inset

 come la forma normale simata di 
\begin_inset Formula $\neg C$
\end_inset

.
\end_layout

\begin_layout Standard
Possiamo allora definire:
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbb{D}:\,\begin{cases}
R_{D} & Insieme\, dei\, nomi\, ruolo\\
clos(D) & Insieme\, di\, tutte\, le\, sottoformule\, in\, NNF
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $clos(D):\,\begin{cases}
D\in clos(D)\\
sottoformule(D)\in clos(D)\\
\sim D\in clos(D)
\end{cases}$
\end_inset


\end_layout

\begin_layout Subsection
Definizione di Tableaux
\end_layout

\begin_layout Standard
Un tableaux è definito come:
\end_layout

\begin_layout Standard
\begin_inset Formula $T=<S,\, L,\,\mathcal{E}>$
\end_inset


\end_layout

\begin_layout Standard
Dove:
\end_layout

\begin_layout Standard
S è un insieme di individui
\end_layout

\begin_layout Standard
\begin_inset Formula $L:\, S\longrightarrow2^{clos(D)}$
\end_inset

 funzione di labelling
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{E}:\, R_{D}\longrightarrow2^{S\times S}$
\end_inset

 funzione di labelling degli archi
\end_layout

\begin_layout Standard
Un tableaux si dice completo se rispetta le seguenti proprietà:
\end_layout

\begin_layout Itemize
\begin_inset Formula $C\in L(s)\implies\sim C\notin L(s)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $C_{1}\sqcap C_{2}\in L(s)\implies C_{1}\in L(s),\, C_{2}\in L(s)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $C_{1}\sqcup C_{2}\in L(s)\implies C_{1}\in L(s)\,\vee\, C_{2}\in L(s)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall R.C\in L(s),\,<s,\, t>\in\mathcal{E}(R)\implies C\in L(t)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\exists R.C\in L(s)\implies\exists t\,|\,<s,\, t>\in\mathcal{E}(R)\,\wedge\, C\in L(t)$
\end_inset


\end_layout

\begin_layout Standard
Il tableaux può essere facilmente interpretato come modello: chiamiamo interpret
azione canonica del tableaux la seguente interpretazione:
\end_layout

\begin_layout Standard
\begin_inset Formula $C^{I}=\{a\in S\,|\, C\in L(a)\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R^{I}=\mathcal{E}(R)$
\end_inset


\end_layout

\begin_layout Subsection
Algoritmo di tableaux per 
\begin_inset Formula $\alc$
\end_inset


\end_layout

\begin_layout Standard
Supponendo di dover verificare la soddisfacibilità del concetto C, sia lo
 stato iniziale del tableaux:
\end_layout

\begin_layout Standard
\begin_inset Formula $T_{0}=\{S_{0},\, L_{0},\,\mathcal{E}_{0}\}$
\end_inset


\end_layout

\begin_layout Standard
con:
\end_layout

\begin_layout Standard
\begin_inset Formula $S_{0}=\{x_{0}\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L_{0}(x_{0})=\{C\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\mathcal{E}_{0}=\emptyset$
\end_inset


\end_layout

\begin_layout Standard
Si applicano le seguenti regole:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\sqcap}$
\end_inset

: se 
\begin_inset Formula $(C_{1}\sqcap C_{2})\in L(x)$
\end_inset

, 
\begin_inset Formula $\{C_{1},\, C_{2}\}\not\subseteq L(x)$
\end_inset

 allora
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(x)\leftarrow L(x)\cup C_{1},\, C_{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\sqcup}$
\end_inset

: se 
\begin_inset Formula $(C_{1}\sqcup C_{2})\in L(x)$
\end_inset

, 
\begin_inset Formula $\{C_{1},\, C_{2}\}\cap L(x)=\emptyset$
\end_inset

 allora 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(x)\leftarrow L(x)\cup C$
\end_inset

 con 
\begin_inset Formula $C=C_{1}\,\vee\, C_{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\exists}$
\end_inset

: se 
\begin_inset Formula $\exists R.C\in L(x)$
\end_inset

, e non esiste y R-succ di x tale che 
\begin_inset Formula $c\in L(y)$
\end_inset

 allora 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(y)\leftarrow C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S\leftarrow S\cup\{y\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}(R)\leftarrow\mathcal{E}(R)\cup<x,\, y>$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\forall}$
\end_inset

: se 
\begin_inset Formula $\forall R.C\in L(x)$
\end_inset

, e y R-succ di x tale che 
\begin_inset Formula $c\notin L(y)$
\end_inset

 allora
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(y)\leftarrow L(y)\cup\{c\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
L'algoritmo termina se:
\end_layout

\begin_layout Enumerate
Il tableaux è completo, ossia non posso più applicare nessuna regola
\end_layout

\begin_layout Enumerate
Clash, ossia C e 
\begin_inset Formula $\sim C$
\end_inset

 sono nella marcatura dello stesso nodo.
 un tableaux che presenta un clash viene detto tableaux chiuso.
\end_layout

\begin_layout Standard
\begin_inset Formula $\alc$
\end_inset

gode di due importanti proprietà:
\end_layout

\begin_layout Enumerate
Modello finito
\end_layout

\begin_layout Enumerate
Modello ad albero
\end_layout

\begin_layout Standard
Ogni formula soddisfacibile ha almeno un modello finito ad albero, quindi
 l'algoritmo di Tableux può limitarsi a cercare questa classe di modelli.
\end_layout

\begin_layout Section
Logica 
\begin_inset Formula $\alc_{R^{+}}$
\end_inset

, o logica S
\end_layout

\begin_layout Standard
la logica 
\begin_inset Formula $\alc_{R^{+}}$
\end_inset

 non è altro che la logica 
\begin_inset Formula $\alc$
\end_inset

 con la possibilità di considerare ruoli transitivi.
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbb{R}^{+}\subseteq\mathbb{R}$
\end_inset


\end_layout

\begin_layout Standard
I ruoli in 
\begin_inset Formula $\mathbb{R}^{+}$
\end_inset

 godono della proprità transitiva, ossia:
\end_layout

\begin_layout Standard
\begin_inset Formula $<x,\, y>\in R^{I}\,\wedge\,<y,\, z>\in R^{I}\,\wedge\, R\in\mathbb{R}^{+}\implies<x,\, z>\in R^{I}$
\end_inset

 
\end_layout

\begin_layout Standard
Per considerare la proprietà transitiva nel nostro tableaux, dobbiamo modificare
 l'algoritmo aggiungendo la regola:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\forall^{+}}$
\end_inset

: se 
\begin_inset Formula $\forall R.C\in L(x)$
\end_inset

, 
\begin_inset Formula $R\in\mathbb{R}^{+}$
\end_inset

, e y R-succ di x tale che 
\begin_inset Formula $\forall R.C\notin L(y)$
\end_inset

 allora
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(y)\leftarrow L(y)\cup\{\forall R.C\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Tuttavia, aggiungere la regola non basta, infatti considerando la seguente
 formula:
\end_layout

\begin_layout Standard
\begin_inset Formula $D\equiv C\sqcap\exists R.C\sqcap\forall R.\exists R.C$
\end_inset

 con 
\begin_inset Formula $R\in\mathbb{R}^{+}$
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L(x)=\{D,\ C,\ \exists R.C,\ \forall R.C,\ \forall R.\exists R.C\}$
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english
\begin_inset Formula $L(y)=\{C,\ \exists R.C,\ \forall R.\exists R.C\}$
\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Formula $L(z)=\{C,\ \exists R.C,\ \forall R.\exists R.C\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\backslash
begin{tikzpicture}[scale=0.2]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{every node}+=[inner sep=0pt] 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-13.4) circle (3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (29.4,-13.4) node {$x$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-24.9) circle (3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (29.4,-24.9) node {$y$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-36.9) circle (3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (29.4,-36.9) node {$z$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (50.7,-13.4) node {$L(x)=
\backslash
{D,
\backslash
 C,
\backslash
 
\backslash
exists R.C,
\backslash
 
\backslash
forall R.C,
\backslash
 
\backslash
forall R.
\backslash
exists R.C
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (45.7,-24.9) node {$L(y)=
\backslash
{C,
\backslash
 
\backslash
exists R.C,
\backslash
 
\backslash
forall R.
\backslash
exists R.C
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (45.7,-36.9) node {$L(z)=
\backslash
{C,
\backslash
 
\backslash
exists R.C,
\backslash
 
\backslash
forall R.
\backslash
exists R.C
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-27.9) -- (29.4,-33.9); 
\backslash
fill [black] (29.4,-33.9) -- (29.9,-33.1) -- (28.9,-33.1); 
\backslash
draw (28.9,-30.9) node [left] {$R$}; 
\backslash
draw [black] (29.4,-16.4) -- (29.4,-21.9); 
\backslash
fill [black] (29.4,-21.9) -- (29.9,-21.1) -- (28.9,-21.1); 
\backslash
draw (28.9,-19.15) node [left] {$R$}; 
\backslash
end{tikzpicture} 
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L(y)\subseteq L(x)\implies x\, blocca\, y$
\end_inset


\end_layout

\begin_layout Standard
Infatti, tutto quello che posso generare per cercare un clash in y, lo posso
 generare in x, inutile quindi proseguire lungo una catena infinita di geneazion
e di nodi identici, e quindi non devo generare nemmeno z.
\end_layout

\begin_layout Standard
Quello che ottengo si chiama completion tree, e non tableaux.
 Per ricavare il tableaux ci sono due vie: cercando un modello aciclico,
 e allora si otterrà un modello infinito ad albero, oppure si può ottenere
 un modello ciclico, collasando i nodi che vengono bloccati in un unico
 mondo col loro bloccante.
\end_layout

\begin_layout Section
Logica SI
\end_layout

\begin_layout Subsection
Definizioni di base
\end_layout

\begin_layout Standard
La logica SI è la logica S con l'aggiunta dei ruoli inversi.
\end_layout

\begin_layout Standard
Diciamo che:
\end_layout

\begin_layout Standard
\begin_inset Formula $<x,\, y>\in(R^{-})^{I}\iff<y,\, x>\in R^{I}$
\end_inset


\end_layout

\begin_layout Standard
e quindi l'insieme dei ruoli in SI sarà:
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbb{R}_{SI}=\mathbb{R}\cup\{R^{-}\,|\, R\in\mathbb{R}\}$
\end_inset


\end_layout

\begin_layout Standard
Deiniamo per comodità la seguente funzione:
\end_layout

\begin_layout Standard
\begin_inset Formula $inv:\,\mathbb{R}_{SI}\longrightarrow\mathbb{R}_{SI}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $inv(R)=\begin{cases}
R^{-} & se\, R\in\mathbb{R}\\
S & se\, R=S^{-},\, S\in\mathbb{R}
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
Inoltre definiamo il predicato trans come:
\end_layout

\begin_layout Standard
\begin_inset Formula $trans(R)\iff\begin{cases}
R\in\mathbb{R}^{+}\\
R=S^{-},\, S\in\mathbb{R}^{+}
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
Diciamo infine che y è R-prox di x se e solo se vale almeno una delle seguenti:
\end_layout

\begin_layout Standard
y è R-successore di x
\end_layout

\begin_layout Standard
x è inv(R)-successore di y
\end_layout

\begin_layout Subsection
Tableaux e bloccaggio
\end_layout

\begin_layout Standard
Consideriamo i seguenti esempi, che costringono l'algoritmo di Tableaux
 a modificarsi:
\end_layout

\begin_layout Standard
es.
 
\begin_inset Formula $\neg C\sqcap\exists R.(C\sqcap\exists R.\neg C)\sqcap\forall R^{-}.\neg C$
\end_inset

 
\begin_inset Formula $ $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\backslash
begin{tikzpicture}[scale=0.2]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{every node}+=[inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-13.4) circle (3); 
\backslash
draw (29.4,-13.4) node {$x$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-24.9) circle (3); 
\backslash
draw (29.4,-24.9) node {$y$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-39.5) circle (3); 
\backslash
draw (29.4,-39.5) node {$z$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (52.7,-13.4) node {$L(x)=
\backslash
{
\backslash
sim C,
\backslash
 
\backslash
exists R.(C
\backslash
sqcap
\backslash
exists R.
\backslash
sim C),
\backslash
 
\backslash
forall R^{-}.
\backslash
sim C
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (50.7,-24.9) node {$L(y)=
\backslash
{(C
\backslash
sqcap
\backslash
exists R.
\backslash
sim C),
\backslash
 C,
\backslash
 
\backslash
exists R.
\backslash
sim C
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (40.4,-39.5) node {$L(z)=
\backslash
{
\backslash
sim C
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.4,-27.9) -- (29.4,-36.5); 
\backslash
fill [black] (29.4,-36.5) -- (29.9,-35.7) -- (28.9,-35.7); 
\backslash
draw (28.9,-32.2) node [left] {$R$}; 
\backslash
draw [black] (29.4,-16.4) -- (29.4,-21.9); 
\backslash
fill [black] (29.4,-21.9) -- (29.9,-21.1) -- (28.9,-21.1); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (28.9,-19.15) node [left] {$R$}; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ma se identifico z con x, in y deve valere 
\begin_inset Formula $\neg C$
\end_inset

 perchè è un 
\begin_inset Formula $R^{-}$
\end_inset

-successore.
 Non posos quindi bloccare il nodo z, ma ridefinisco la condizione di bloccaggio
 come:
\end_layout

\begin_layout Standard
\begin_inset Formula $L(z)=L(x)$
\end_inset


\end_layout

\begin_layout Standard
Ossia effettuo il bloccaggio solo se le due marcature sono uguali.
\begin_inset Newline newline
\end_inset

es.
 
\begin_inset Formula $A\sqcap\exists S.(\exists R.T\sqcap\exists P.T\sqcap\forall R.C\sqcap\forall P.\exists R.T\sqcap\forall P.\forall R.C\sqcap\forall P.\exists P.T)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C=\forall R^{-}.\forall P^{-}.\forall S^{-}.\neg A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L(x)=$
\end_inset


\begin_inset Formula $\{D,\ A,\ \exists R.(\exists R.T\sqcap\exists P.T\sqcap\forall R.C\sqcap\forall P.\exists R.T\sqcap\forall P.\forall R.C\sqcap\forall P.\exists P.T)\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L(y)=$
\end_inset

 
\begin_inset Formula $\{\exists R,\ \exists P,\ \forall R.C,\ \forall P.\exists R,\ \forall P.\exists R,\ \forall P.\exists P,\ \forall P.\forall R.C\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L(z)=$
\end_inset

 
\begin_inset Formula $\{\exists R,\ \exists P,\ \forall R.C,\ \forall P.\forall R.C,\ \forall P.\\fo$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\backslash
begin{tikzpicture}[scale=0.2] 
\backslash
tikzstyle{every node}+=[inner sep=0pt] 
\backslash
draw [black] (47.4,-7.8) circle (3); 
\backslash
draw (47.4,-7.8) node {$x$}; 
\backslash
draw [black] (47.4,-22.3) circle (3); 
\backslash
draw (47.4,-22.3) node {$y$}; 
\backslash
draw [black] (47.4,-37.2) circle (3); 
\backslash
draw (47.4,-37.2) node {$z$};
\end_layout

\begin_layout Plain Layout


\backslash
draw (65.2,-7.8) node {$lx$};
\end_layout

\begin_layout Plain Layout


\backslash
draw (65.2,-23.6) node {$ly$};
\end_layout

\begin_layout Plain Layout


\backslash
draw (65.2,-37.2) node {$lz$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (7.4,-32.7) circle (3); 
\backslash
draw (7.4,-32.7) node {$v$}; 
\backslash
draw [black] (10.8,-47.3) circle (3); 
\backslash
draw (10.8,-47.3) node {$u$};
\end_layout

\begin_layout Plain Layout


\backslash
draw (26.3,-47.3) node {$lu$};
\end_layout

\begin_layout Plain Layout


\backslash
draw (25.3,-32.7) node {$lv$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (47.4,-25.3) -- (47.4,-34.2); 
\backslash
fill [black] (47.4,-34.2) -- (47.9,-33.4) -- (46.9,-33.4); 
\backslash
draw (46.9,-29.75) node [left] {$R$}; 
\backslash
draw [black] (47.4,-10.8) -- (47.4,-19.3); 
\backslash
fill [black] (47.4,-19.3) -- (47.9,-18.5) -- (46.9,-18.5); 
\backslash
draw (46.9,-15.05) node [left] {$R$}; 
\backslash
draw [black] (9.357,-30.427) arc (136.7599:72.38853:34.167); 
\backslash
fill [black] (9.36,-30.43) -- (10.27,-30.19) -- (9.54,-29.5); 
\backslash
draw (24.79,-20.19) node [above] {$R$}; 
\backslash
draw [black] (8.08,-35.62) -- (10.12,-44.38); 
\backslash
fill [black] (10.12,-44.38) -- (10.43,-43.49) -- (9.45,-43.71); 
\backslash
draw (8.35,-40.41) node [left] {$R$}; 
\backslash
end{tikzpicture} 
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si possono notare due cose dall'esempio precedente, ossia, il blocco è dinamico,
 i nodi si possono bloccare e sbloccare, ed esistono due tipi di bloccaggio:
\end_layout

\begin_layout Enumerate
Bloccaggio indiretto: un nodo è bloccato indirettamente se un suo antenato
 è bloccato
\end_layout

\begin_layout Enumerate
Bloccaggio diretto: un antenato del nodo ha la stessa marcatura, e il nodo
 non è bloccato indirettamente
\end_layout

\begin_layout Standard
Il bloccaggio stretto si applica ai nodi bloccati indirettamente.
\end_layout

\begin_layout Subsection
Algoritmo di Tableaux
\end_layout

\begin_layout Standard
L'algoritmo di tableaux va quindi così ridefinito:
\end_layout

\begin_layout Standard
\begin_inset Formula $L(x)\subseteq clos(D)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L(<x,\, y>)\in\mathbb{R}_{SI}$
\end_inset


\end_layout

\begin_layout Standard
e le regole verranno modificate come segue:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\sqcap}$
\end_inset

: se 
\begin_inset Formula $(C_{1}\sqcap C_{2})\in L(x)$
\end_inset

, 
\begin_inset Formula $\{C_{1},\, C_{2}\}\not\subseteq L(x)$
\end_inset

 e il nodo x non è bloccato indirettamente allora
\end_layout

\begin_layout Itemize
\begin_inset Formula $L(x)\leftarrow L(x)\cup C_{1},\, C_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\sqcup}$
\end_inset

: se 
\begin_inset Formula $(C_{1}\sqcup C_{2})\in L(x)$
\end_inset

, 
\begin_inset Formula $\{C_{1},\, C_{2}\}\cap L(x)=\emptyset$
\end_inset

 e il nodo x non è bloccato indirettamente allora 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(x)\leftarrow L(x)\cup C$
\end_inset

 con 
\begin_inset Formula $C=C_{1}\,\vee\, C_{2}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\exists}$
\end_inset

: se 
\begin_inset Formula $\exists R.C\in L(x)$
\end_inset

, e non esiste y R-prox di x tale che 
\begin_inset Formula $c\in L(y)$
\end_inset

 e il nodo x non è bloccato, ne direttamente ne indirettamente, allora 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(y)\leftarrow C$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S\leftarrow S\cup\{y\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\mathcal{E}(R)\leftarrow\mathcal{E}(R)\cup<x,\, y>$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\forall}$
\end_inset

: se 
\begin_inset Formula $\forall R.C\in L(x)$
\end_inset

, e y R-prox di x tale che 
\begin_inset Formula $c\notin L(y)$
\end_inset

 e il nodo x non è bloccato indirettamente allora
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(y)\leftarrow L(y)\cup\{C\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\forall^{+}}$
\end_inset

: se 
\begin_inset Formula $\forall R.C\in L(x)$
\end_inset

, 
\begin_inset Formula $trans(R)$
\end_inset

, e y R-prox di x tale che 
\begin_inset Formula $\forall R.C\notin L(y)$
\end_inset

 e x non è bloccato indirettamente allora
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(y)\leftarrow L(y)\cup\{\forall R.C\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Section
Logica SHI
\end_layout

\begin_layout Subsection
Definizione della logica SHI
\end_layout

\begin_layout Standard
Lo logica SHI include, oltre a tutti i costrutti in SI, anche I Role Inclusion
 Axioms (RIA):
\end_layout

\begin_layout Standard
\begin_inset Formula $R\sqsubseteq S$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R\equiv S$
\end_inset


\end_layout

\begin_layout Standard
l'ultimo costrutto è equivalente a:
\end_layout

\begin_layout Standard
\begin_inset Formula $R\sqsubseteq S$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $S\sqsubseteq R$
\end_inset


\end_layout

\begin_layout Standard
Chiamiamo gli insiemi:
\end_layout

\begin_layout Standard
\begin_inset Formula $RIA_{S}=\{R\sqsubseteq S_{i}\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $RIA_{S^{+}}=RIA_{S}\cup\{inv(R)\sqsubseteq inv(S)\,|\, R\sqsubseteq S\in RIA_{S},\,\sqsubseteq_{*}\}$
\end_inset


\end_layout

\begin_layout Subsection
Algoritmo di Tableaux per SHI
\end_layout

\begin_layout Standard
Per estendere l'algoritmo di tableaux dobbiamo attuare le seguenti modifiche:
\end_layout

\begin_layout Enumerate
y è S-prox di X se e solo se 
\begin_inset Formula $R\sqsubseteq S\in RIA_{S^{+}}$
\end_inset

 e y è R-succ di x oppure xinv(R)-succ di y.
\end_layout

\begin_layout Enumerate
modifico la regola 
\begin_inset Formula $\forall_{+}$
\end_inset

, esistono due modi equivalenti per estenderla nel caso di sottoruoli di
 ruoli transitivi:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $\longrightarrow_{\forall^{+'}}$
\end_inset

: se 
\begin_inset Formula $\forall S.C\in L(x)$
\end_inset

, 
\begin_inset Formula $R\sqsubseteq S\in RIA_{S^{+}}$
\end_inset

 , 
\begin_inset Formula $trans(R)$
\end_inset

 e y R-prox di x tale che 
\begin_inset Formula $\forall R.C\notin L(y)$
\end_inset

, e x non è bloccato indirettamente allora
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $L(y)\leftarrow L(y)\cup\{\forall R.C\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset Formula $\longrightarrow_{\forall^{+''}}$
\end_inset

: se 
\begin_inset Formula $\forall S.C\in L(x)$
\end_inset

, 
\begin_inset Formula $R\sqsubseteq S\in RIA_{S^{+}}$
\end_inset

 , 
\begin_inset Formula $trans(R)$
\end_inset

 e x non è bloccato indirettamente allora
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $L(x)\leftarrow L(x)\cup\{\forall R.C\}$
\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Internalizzazzione
\end_layout

\begin_layout Standard
Con SHI abbiamo abbastanza potere espressivo da poter esprimere nella nostra
 logica la soddisfacibilità della knowledge base direttamente nell'algoritmo
 di tableaux.
 Per dimostrare che un concetto c è insoddisfacibile:
\end_layout

\begin_layout Standard
\begin_inset Formula $\vera T{C\sqsubseteq\bot}$
\end_inset


\end_layout

\begin_layout Standard
Costruiamo un concetto C' tale che C è soddisfacibile nel T-box T se e solo
 se:
\end_layout

\begin_layout Standard
\begin_inset Formula $\models C'\sqsubseteq\bot$
\end_inset


\end_layout

\begin_layout Standard
Per farlo supponiamo che il T-box sia:
\end_layout

\begin_layout Standard
\begin_inset Formula $T=\{C_{1}\sqsubseteq D_{1},\,\ldots,\, C_{n}\sqsubseteq D_{n}\}$
\end_inset


\end_layout

\begin_layout Standard
allora possiamo definire il concetto:
\end_layout

\begin_layout Standard
\begin_inset Formula $C_{T}=\underset{C_{i}\sqsubseteq D_{i}\in T}{\bigsqcap}(\neg C_{1}\sqcup\, D_{1})$
\end_inset


\end_layout

\begin_layout Standard
e definiamo quindi:
\end_layout

\begin_layout Standard
\begin_inset Formula $C'\equiv C\sqcap C_{T}$
\end_inset


\end_layout

\begin_layout Standard
Tuttavia non è sufficiente, perchè è necessario che il concetto 
\begin_inset Formula $C_{T}$
\end_inset

 sia propragato in tutti i nodi della knowledge base, per ottenere il risultato
 desiderato, costruisco un ruolo U che sia una approssimazione del ruolo
 universale, ovvero che sia un sopraruolo di tutti i ruoli usati nella T-Box.
\end_layout

\begin_layout Standard
Il concetto C' diventa:
\end_layout

\begin_layout Standard
\begin_inset Formula $C'\equiv C\sqcap C_{T}\sqcap\forall U.C_{T}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $U\in R^{+}$
\end_inset


\end_layout

\begin_layout Section
Logiche con vincoli di cardinalità
\end_layout

\begin_layout Subsection
Logiche SHIF, SHIN, e SHIQ
\end_layout

\begin_layout Standard
La logica SHI può essere estesa aggiungendo i vincoli di cardinalità, aggiungend
o gli schemi F, N, Q, in ordine di potenza espressiva:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq1R$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{x\in\Delta^{I}\,|\,\#\{y\,|\,<x,\, y>\in R^{I}\}\leq1\}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq nR$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{x\in\Delta^{I}\,|\,\#\{y\,|\,<x,\, y>\in R^{I}\}\leq n\}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Q
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\leq nR.C$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{x\in\Delta^{I}\,|\,\#\{y\,|\,<x,\, y>\in R^{I}\wedge y\in C^{I}\}\leq n\}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Indecidibilità di 
\begin_inset Formula $SHIN^{+}$
\end_inset


\end_layout

\begin_layout Standard
La logica 
\begin_inset Formula $SHIN^{+}$
\end_inset

 è la logica SHIN con la possibilità di usare liberamente i vincoli di cardinali
tà anche per i ruoli transitivi.
 Si può dimostrare che la logica 
\begin_inset Formula $SHIN^{+}$
\end_inset

 è indecidibile, e per mostrarlo si mostra che un problema indecidibile
 può essere rappresentato in essa.
\end_layout

\begin_layout Standard
Consideriamo il problema del domino:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
definecolor{c422c18}{RGB}{66,44,24} 
\end_layout

\begin_layout Plain Layout


\backslash
definecolor{cffffff}{RGB}{255,255,255} 
\end_layout

\begin_layout Plain Layout


\backslash
definecolor{caaffaa}{RGB}{170,255,170}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[y=0.80pt,x=0.80pt,yscale=-1,
\end_layout

\begin_layout Plain Layout

inner sep=0pt, outer sep=0pt]  
\end_layout

\begin_layout Plain Layout


\backslash
path[draw=c422c18,fill=cffffff,opacity=0.970,rounded corners=0.0000cm] 
\end_layout

\begin_layout Plain Layout

   (110.8864,113.6076) rectangle (613.6557,426.1058);  
\end_layout

\begin_layout Plain Layout


\backslash
path[draw=black,line join=miter,line cap=butt,line
\end_layout

\begin_layout Plain Layout

width=0.800pt]     (360.0000,112.3750) 
\end_layout

\begin_layout Plain Layout

-- (360.0000,432.3750) -- (360.0000,112.3750) 
\end_layout

\begin_layout Plain Layout

-- cycle;   
\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.800pt] 
\end_layout

\begin_layout Plain Layout

   (110.0000,265.3622) -- (615.0000,265.3622);   
\backslash
path[draw=black,line 
\end_layout

\begin_layout Plain Layout

join=miter,line cap=butt,line width=0.800pt]     (235.0000,427.3622) 
\end_layout

\begin_layout Plain Layout

-- (235.0000,112.3622);   
\backslash
path[draw=black,line join=miter,line 
\end_layout

\begin_layout Plain Layout

cap=butt,line width=0.800pt]     (489.0000,427.3622) -- (489.0000,112.3622);
 
\end_layout

\begin_layout Plain Layout

 
\backslash
path[draw=black,line join=miter,line cap=butt,line width=0.800pt]    
\end_layout

\begin_layout Plain Layout

(615.0000,351.3622) -- (110.0000,351.3622);   
\backslash
path[draw=black,line 
\end_layout

\begin_layout Plain Layout

join=miter,line cap=butt,line width=0.800pt]     (615.0000,190.3622)
\end_layout

\begin_layout Plain Layout

-- (110.0000,190.3622);   
\backslash
path[draw=c422c18,fill=caaffaa,opacity=0.970,
\end_layout

\begin_layout Plain Layout

line width=0.813pt,rounded     corners=0.0000cm] (360.0084,190.6042)
\end_layout

\begin_layout Plain Layout

rectangle (488.7551,265.5333);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ho un quadrante da ricoprire con delle tessere, rispettando un insieme di
 regole che mi vincolano la vicinanza tra le tessere.
 Esistono vincoli orizzontali e verticali.
\end_layout

\begin_layout Standard
Dati:
\end_layout

\begin_layout Standard
\begin_inset Formula $D=\{D_{1},\ldots D_{n}\}$
\end_inset

 insieme di n tessere
\end_layout

\begin_layout Standard
\begin_inset Formula $H,V\subseteq D\times D$
\end_inset

 insieme di regole
\end_layout

\begin_layout Standard
Il problema di decidere se esiste una copertura che rispetta le regole e
 che copra l'intero quadrante è indecidibile, o più formalmente:
\end_layout

\begin_layout Standard
\begin_inset Formula $t:\,\mathbb{N}^{2}\longrightarrow D\,|\,<t(m,\, n),\, t(m+n,\, n)>\in H\wedge<t(m,\, n),\, t(m,\, n+1)>\in V$
\end_inset

 
\end_layout

\begin_layout Standard
il problema di determinare t è indecidibile.
\end_layout

\begin_layout Standard
Per modellare lo spazio degli stati usiamo il seguente sistema:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\backslash
begin{tikzpicture}[scale=0.2] 
\backslash
tikzstyle{every node}+=[inner sep=0pt] 
\backslash
draw [black] (13.2,-37.8) circle (3); 
\backslash
draw (13.2,-37.8) node {$A$}; 
\backslash
draw [black] (31.2,-37.8) circle (3); 
\backslash
draw (31.2,-37.8) node {$B$}; 
\backslash
draw [black] (31.2,-22.5) circle (3); 
\backslash
draw (31.2,-22.5) node {$D$}; 
\backslash
draw [black] (13.2,-22.5) circle (3); 
\backslash
draw (13.2,-22.5) node {$C$}; 
\backslash
draw [black] (48.4,-37.8) circle (3); 
\backslash
draw (48.4,-37.8) node {$A$}; 
\backslash
draw [black] (48.4,-22.5) circle (3); 
\backslash
draw (48.4,-22.5) node {$C$}; 
\backslash
draw [black] (13.2,-7.5) circle (3); 
\backslash
draw (13.2,-7.5) node {$A$}; 
\backslash
draw [black] (31.2,-7.5) circle (3); 
\backslash
draw (31.2,-7.5) node {$B$}; 
\backslash
draw [black] (48.4,-7.5) circle (3); 
\backslash
draw (48.4,-7.5) node {$A$}; 
\backslash
draw [black] (62.9,-37.8) circle (3); 
\backslash
draw (62.9,-37.8) node {$...$}; 
\backslash
draw [black] (62.9,-7.5) circle (3); 
\backslash
draw (62.9,-7.5) node {$...$}; 
\backslash
draw [black] (62.9,-22.5) circle (3); 
\backslash
draw (62.9,-22.5) node {$...$}; 
\backslash
draw [black] (16.2,-22.5) -- (28.2,-22.5); 
\backslash
fill [black] (28.2,-22.5) -- (27.4,-22) -- (27.4,-23); 
\backslash
draw (22.2,-23) node [below] {$x1$}; 
\backslash
draw [black] (13.2,-34.8) -- (13.2,-25.5); 
\backslash
fill [black] (13.2,-25.5) -- (12.7,-26.3) -- (13.7,-26.3); 
\backslash
draw (13.7,-30.15) node [right] {$y1$}; 
\backslash
draw [black] (31.2,-34.8) -- (31.2,-25.5); 
\backslash
fill [black] (31.2,-25.5) -- (30.7,-26.3) -- (31.7,-26.3); 
\backslash
draw (31.7,-30.15) node [right] {$y1$}; 
\backslash
draw [black] (34.2,-22.5) -- (45.4,-22.5); 
\backslash
fill [black] (45.4,-22.5) -- (44.6,-22) -- (44.6,-23); 
\backslash
draw (39.8,-23) node [below] {$x2$}; 
\backslash
draw [black] (48.4,-34.8) -- (48.4,-25.5); 
\backslash
fill [black] (48.4,-25.5) -- (47.9,-26.3) -- (48.9,-26.3); 
\backslash
draw (48.9,-30.15) node [right] {$y1$}; 
\backslash
draw [black] (34.2,-37.8) -- (45.4,-37.8); 
\backslash
fill [black] (45.4,-37.8) -- (44.6,-37.3) -- (44.6,-38.3); 
\backslash
draw (39.8,-38.3) node [below] {$x2$}; 
\backslash
draw [black] (13.2,-19.5) -- (13.2,-10.5); 
\backslash
fill [black] (13.2,-10.5) -- (12.7,-11.3) -- (13.7,-11.3); 
\backslash
draw (13.7,-15) node [right] {$y2$}; 
\backslash
draw [black] (31.2,-19.5) -- (31.2,-10.5); 
\backslash
fill [black] (31.2,-10.5) -- (30.7,-11.3) -- (31.7,-11.3); 
\backslash
draw (31.7,-15) node [right] {$y2$}; 
\backslash
draw [black] (48.4,-19.5) -- (48.4,-10.5); 
\backslash
fill [black] (48.4,-10.5) -- (47.9,-11.3) -- (48.9,-11.3); 
\backslash
draw (48.9,-15) node [right] {$y2$}; 
\backslash
draw [black] (16.2,-7.5) -- (28.2,-7.5); 
\backslash
fill [black] (28.2,-7.5) -- (27.4,-7) -- (27.4,-8); 
\backslash
draw [black] (34.2,-7.5) -- (45.4,-7.5); 
\backslash
fill [black] (45.4,-7.5) -- (44.6,-7) -- (44.6,-8); 
\backslash
draw [black] (16.2,-37.8) -- (28.2,-37.8); 
\backslash
fill [black] (28.2,-37.8) -- (27.4,-37.3) -- (27.4,-38.3); 
\backslash
draw (22.2,-38.3) node [below] {$x1$}; 
\backslash
draw [black] (51.4,-22.5) -- (59.9,-22.5); 
\backslash
fill [black] (59.9,-22.5) -- (59.1,-22) -- (59.1,-23); 
\backslash
draw [black] (51.4,-37.8) -- (59.9,-37.8); 
\backslash
fill [black] (59.9,-37.8) -- (59.1,-37.3) -- (59.1,-38.3); 
\backslash
draw [black] (51.4,-7.5) -- (59.9,-7.5); 
\backslash
fill [black] (59.9,-7.5) -- (59.1,-7) -- (59.1,-8); 
\backslash
end{tikzpicture} 
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $A\sqsubseteq\neg B\sqcap\neg C\sqcap\neg D\sqcap\exists X_{1}.B\sqcap\exists Y_{1}.C$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $B\sqsubseteq\neg A\sqcap\neg C\sqcap\neg D\sqcap\exists X_{2}.A\sqcap\exists Y_{1}.D$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C\sqsubseteq\neg A\sqcap\neg B\sqcap\neg D\sqcap\exists X_{1}.D\sqcap\exists Y_{2}.A$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D\sqsubseteq\neg A\sqcap\neg B\sqcap\neg C\sqcap\exists X_{2}.C\sqcap\exists Y_{2}.B$
\end_inset


\end_layout

\begin_layout Standard
Ma questo modello non basta, dobbiamo considerare che il mondo raggiunto
 applicando prima 
\begin_inset Formula $X_{1}$
\end_inset

 e poi 
\begin_inset Formula $Y_{1}$
\end_inset

 è lo stesso raggiunto applicando prima 
\begin_inset Formula $Y_{1}$
\end_inset

 e poi 
\begin_inset Formula $X_{1}$
\end_inset

 .
 Per farlo definiamo le relazioni 
\begin_inset Formula $S_{ij}\in\mathbb{R}^{+}$
\end_inset

 definite così:
\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{11}\sqsubseteq X_{1}$
\end_inset

, 
\begin_inset Formula $S_{11}\sqsubseteq Y_{1}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{12}\sqsubseteq X_{1}$
\end_inset

, 
\begin_inset Formula $S_{12}\sqsubseteq Y_{2}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{21}\sqsubseteq X_{2}$
\end_inset

, 
\begin_inset Formula $S_{21}\sqsubseteq Y_{1}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{22}\sqsubseteq X_{2}$
\end_inset

, 
\begin_inset Formula $S_{22}\sqsubseteq Y_{2}$
\end_inset


\end_layout

\begin_layout Standard
Allora avremo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\backslash
begin{tikzpicture}[scale=0.2] 
\backslash
tikzstyle{every node}+=[inner sep=0pt] 
\backslash
draw [black] (35,-7.7) circle (3); 
\backslash
draw (35,-7.7) node {$A$}; 
\backslash
draw [black] (24.6,-19.4) circle (3); 
\backslash
draw (24.6,-19.4) node {$B$}; 
\backslash
draw [black] (47.3,-19.4) circle (3); 
\backslash
draw (47.3,-19.4) node {$C$}; 
\backslash
draw [black] (17.3,-32.5) circle (3); 
\backslash
draw (17.3,-32.5) node {$D$}; 
\backslash
draw [black] (29.4,-32.5) circle (3); 
\backslash
draw (29.4,-32.5) node {$A$}; 
\backslash
draw [black] (41.7,-32.5) circle (3); 
\backslash
draw (41.7,-32.5) node {$D$}; 
\backslash
draw [black] (55.5,-32.5) circle (3); 
\backslash
draw (55.5,-32.5) node {$A$}; 
\backslash
draw [black] (33.01,-9.94) -- (26.59,-17.16); 
\backslash
fill [black] (26.59,-17.16) -- (27.5,-16.89) -- (26.75,-16.23); 
\backslash
draw (29.26,-12.1) node [left] {$x1$}; 
\backslash
draw [black] (37.17,-9.77) -- (45.13,-17.33); 
\backslash
fill [black] (45.13,-17.33) -- (44.89,-16.42) -- (44.2,-17.14); 
\backslash
draw (42.67,-13.07) node [above] {$y1$}; 
\backslash
draw [black] (23.14,-22.02) -- (18.76,-29.88); 
\backslash
fill [black] (18.76,-29.88) -- (19.59,-29.42) -- (18.71,-28.94); 
\backslash
draw (20.29,-24.75) node [left] {$y1$}; 
\backslash
draw [black] (25.63,-22.22) -- (28.37,-29.68); 
\backslash
fill [black] (28.37,-29.68) -- (28.56,-28.76) -- (27.62,-29.1); 
\backslash
draw (27.76,-25.15) node [right] {$x2$}; 
\backslash
draw [black] (46.12,-22.16) -- (42.88,-29.74); 
\backslash
fill [black] (42.88,-29.74) -- (43.65,-29.2) -- (42.73,-28.81); 
\backslash
draw (43.77,-25) node [left] {$x1$}; 
\backslash
draw [black] (48.89,-21.94) -- (53.91,-29.96); 
\backslash
fill [black] (53.91,-29.96) -- (53.91,-29.01) -- (53.06,-29.54); 
\backslash
draw (52.03,-24.66) node [right] {$y2$}; 
\backslash
draw [black] (40.084,-35.02) arc (-38.98242:-141.01758:13.616); 
\backslash
fill [black] (40.08,-35.02) -- (39.19,-35.33) -- (39.97,-35.96); 
\backslash
draw (29.5,-40.57) node [below] {$Collassabili!$}; 
\backslash
draw [black] (40.082,-35.019) arc (-39.01649:-140.98351:13.62); 
\backslash
fill [black] (18.92,-35.02) -- (19.03,-35.96) -- (19.81,-35.33); 
\backslash
end{tikzpicture} 
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Per fare collassare le coppie di strati ridondanti, basta aggiungere a ogni
 concetto del modello un vincolo di cardinalità sulle 
\begin_inset Formula $S_{ij}$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $A\sqsubseteq\neg B\sqcap\neg C\sqcap\neg D\sqcap\exists X_{1}.B\sqcap\exists Y_{1}.C\sqcap\leq3S_{11}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $B\sqsubseteq\neg A\sqcap\neg C\sqcap\neg D\sqcap\exists X_{2}.A\sqcap\exists Y_{1}.D\sqcap\leq3S_{21}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C\sqsubseteq\neg A\sqcap\neg B\sqcap\neg D\sqcap\exists X_{1}.D\sqcap\exists Y_{2}.A\sqcap\leq3S_{12}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $D\sqsubseteq\neg A\sqcap\neg B\sqcap\neg C\sqcap\exists X_{2}.C\sqcap\exists Y_{2}.B\sqcap\leq3S_{22}$
\end_inset


\end_layout

\begin_layout Standard
Ora si pososno modellizzare le tessere con dei concetti:
\end_layout

\begin_layout Standard
\begin_inset Formula $\mathbb{C}=\{C_{D_{1}},\ldots,\, C_{D_{n}}\}$
\end_inset


\end_layout

\begin_layout Standard
Imponiamo ora la copertura totale del quadrante:
\end_layout

\begin_layout Standard
\begin_inset Formula $A\sqcup B\sqcup C\sqcup D\sqsubseteq\underset{i}{\bigsqcup}C_{D_{i}}$
\end_inset


\end_layout

\begin_layout Standard
Infine imponiamo la presenza di una unica tessera per casella tramite le
 formule:
\end_layout

\begin_layout Standard
\begin_inset Formula $C_{D_{i}}\sqsubseteq\leq1C_{D_{j}}$
\end_inset

 con 
\begin_inset Formula $1\leq i<j\leq n$
\end_inset


\end_layout

\begin_layout Standard
Per rappresentare i vincoli H e V prima di tutto definiamo i sopraruoli
 X e Y:
\end_layout

\begin_layout Standard
\begin_inset Formula $X\sqsubseteq X_{1}$
\end_inset

, 
\begin_inset Formula $X\sqsubseteq Y_{1}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y\sqsubseteq Y_{1}$
\end_inset

, 
\begin_inset Formula $Y\sqsubseteq Y_{2}$
\end_inset


\end_layout

\begin_layout Standard
Dunque esprimiamo i vincoli con la seguente formula:
\end_layout

\begin_layout Standard
\begin_inset Formula $C_{D_{i}}\sqsubseteq\forall X.\left(\underset{<D_{i},\, D_{j}>\in H}{\bigsqcup}C_{D_{j}}\right)\sqcap\forall Y.\left(\underset{<D_{i},\, D_{j}>\in V}{\bigsqcup}C_{D_{j}}\right)$
\end_inset


\end_layout

\begin_layout Standard
Ora basta considerare il test di soddisfacibilità seguente:
\end_layout

\begin_layout Standard
\begin_inset Formula $\vera T{A\sqsubseteq\bot}$
\end_inset


\end_layout

\begin_layout Standard
ossia, chiedersi se il concetto A è soddisfacibile (e come conseguenza la
 copertura)
\end_layout

\begin_layout Standard
Ma, poichè il problema del domino non è decidibile, e la logica 
\begin_inset Formula $SHIN^{+}$
\end_inset

 permette di modellizzare un problema indecidibile, allora anche 
\begin_inset Formula $SHIN^{+}$
\end_inset

è una logica non decidibile.
\end_layout

\begin_layout Standard
Cio che causa l'indecidibilità della logica è l'applicazione di un vincolo
 di cardinalità al ruolo transitivo.
\end_layout

\begin_layout Standard
I vincoli di cardinalità possono allora essere applicati solamente ai ruoli
 semplici.
\end_layout

\begin_layout Standard
Si definisce Rolo semplice un ruolo che non è transitivo e non ha sottoruoli
 transitivi.
\end_layout

\begin_layout Subsection
Modello finito
\end_layout

\begin_layout Standard
La logica SHIF e tutte le logiche più espressive non hanno la proprietà
 di modello finito, infatti si può dimostrare considerando la seguente formula:
\end_layout

\begin_layout Standard
\begin_inset Formula $\neg A\sqcap\exists S.A\sqcap\forall R.(\exists S.A\sqcap\leq1S^{-})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R\sqsubseteq S$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $R\in\mathcal{R}^{+}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.2] 
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{every node}+=[inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (10.5,-19.6) circle (3); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (10.5,-19.6) node {$x$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (32.9,-19.6) circle (3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (32.9,-19.6) node {$y$};
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (52.4,-19.6) circle (3); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (52.4,-19.6) node {$z$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (10.5,-13.8) node {$L(x)=
\backslash
{
\backslash
neg A,
\backslash
dots
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (32.9,-14.2) node {$L(y)=
\backslash
{A,
\backslash
 
\backslash
exists S.A,
\backslash
dots
\backslash
}$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw (55.1,-14.3) node {$L(z)=
\backslash
{A,
\backslash
 
\backslash
exists S.A,
\backslash
dots
\backslash
}$}; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (13.5,-19.6) -- (29.9,-19.6); 
\backslash
fill [black] (29.9,-19.6) -- (29.1,-19.1) -- (29.1,-20.1); 
\backslash
draw (21.7,-20.1) node [below] {$S$}; 
\backslash
draw [black] (35.9,-19.6) -- (49.4,-19.6); 
\backslash
fill [black] (49.4,-19.6) -- (48.6,-19.1) -- (48.6,-20.1); 
\backslash
draw (42.65,-20.1) node [below] {$S$}; 
\backslash
end{tikzpicture} 
\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Non posso identificare z con y: infatti identificando z con y non solo avrei
 x come 
\begin_inset Formula $S^{-}$
\end_inset

-prox per y, ma anche se stesso a causa dell'autoanello, ma poichè posso
 avere un solo s-prox a causa del concetto 
\begin_inset Formula $\leq1S^{-}$
\end_inset

, non posso avere un modello finito (ma una infinità numerabile di mondi
 in catena è un valido modello per il sistema)
\end_layout

\begin_layout Subsection
Tableaux per SHIQ
\end_layout

\begin_layout Standard
Definiamo i tableaux per la logica SHIQ come:
\end_layout

\begin_layout Standard
\begin_inset Formula $T=\{S,\, L,\,\neq\}$
\end_inset


\end_layout

\begin_layout Standard
Dove S è l'insieme di mondi, L è la funzione di etichettatura dei mondi,
 e 
\begin_inset Formula $\neq$
\end_inset

 è la funzione che dice quali mondi sono necessariamente distinti.
\end_layout

\begin_layout Standard
Inizializiamo il tableaux con:
\end_layout

\begin_layout Standard
\begin_inset Formula $S_{0}=\{x\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $L_{0}(x)=\{C\}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\neq_{0}=\emptyset$
\end_inset


\end_layout

\begin_layout Standard
Dobbiamo aggiungere tre regole nuove all'algoritmo di tableaux per SHI:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\geq}$
\end_inset

: se 
\begin_inset Formula $\geq nR.C\in L(x)$
\end_inset

, il nodo x non è bloccato ne direttamente ne indirettamente, e non ci sono
 n R-prox di x, 
\begin_inset Formula $y_{1},\ldots,\, y_{n}$
\end_inset

 tali che 
\begin_inset Formula $C\in L(y_{i})$
\end_inset

 e 
\begin_inset Formula $\neq(y_{i},\, y_{j})\,\forall1\leq i<j\leq n$
\end_inset

, allora 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $S\leftarrow S\cup\{y_{1},\ldots,\, y_{n}\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $L(x,\, y_{i})\leftarrow\{R\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $L(y_{i})=\{C\}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\neq\leftarrow\neq\cup\{<y_{i},\, y_{j}>,\,\forall1\leq i<j\leq n,\,\forall1\leq j<i\leq n\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{\leq}$
\end_inset

: se 
\begin_inset Formula $\leq nR.C\in L(x)$
\end_inset

, il nodo x non è bloccato indirettamente e esistono n+1 R-prox di x, 
\begin_inset Formula $y_{1},\ldots,\, y_{n}$
\end_inset

 tali che 
\begin_inset Formula $C\in L(y_{i})$
\end_inset

 e esistono y, z R-prox di xtali che 
\begin_inset Formula $C\in L(y)$
\end_inset

 e 
\begin_inset Formula $C\in L(z)$
\end_inset

 e 
\begin_inset Formula $<y,\, z>\notin\neq$
\end_inset

 e y non è antenato di x allora
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(z)\leftarrow L(z)\cup L(y)$
\end_inset


\end_layout

\begin_layout Itemize
se z è antenato di x allora: 
\begin_inset Formula $L(<z,\, x>)\leftarrow L(<z,\, x>)\cup inv(L(<x,\, y>))$
\end_inset


\end_layout

\begin_layout Itemize
se z è discendente di x allora: 
\begin_inset Formula $L(<z,\, x>)\leftarrow L(<z,\, x>)\cup L(<x,\, y>)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $L(<z,\, x>)=\emptyset$
\end_inset


\end_layout

\begin_layout Itemize
aggiungi 
\begin_inset Formula $w\neq z$
\end_inset

 per ogni 
\begin_inset Formula $w\neq y$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\longrightarrow_{R?}$
\end_inset

: se 
\begin_inset Formula $\leq nR.C\in L(x)$
\end_inset

, x non è bloccato indirettamente e y R-prox di x con 
\begin_inset Formula $\{C,\,\neg C\}\cap L(x)=\emptyset$
\end_inset

 allora
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $L(y)\leftarrow L(y)\cup\{C\}$
\end_inset

 con 
\begin_inset Formula $C\in\{C,\,\neg C\}$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Quest'ultima regola, detta regola della scelta, per n molto grande genera
 un'esposione di stati, tuttavia è necessaria per gestire casi del tipo:
\end_layout

\begin_layout Standard
\begin_inset Formula $D\equiv\geq3R.A\sqcap\leq1R.B\sqcap1.R\neg B$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
begin{center} 
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[scale=0.2]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{every node}+=[inner sep=0pt] 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (10.5,-19.6) circle (3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (10.5,-19.6) node {$x$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (29.5,-9.5) circle (3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (29.5,-9.5) node {$y1$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (30.2,-19.6) circle (3);
\end_layout

\begin_layout Plain Layout


\backslash
draw (30.2,-19.6) node {$y2$}; 
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (30.2,-29.6) circle (3); 
\end_layout

\begin_layout Plain Layout


\backslash
draw (30.2,-29.6) node {$y3$};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (13.15,-18.19) -- (26.85,-10.91);
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (26.85,-10.91) -- (25.91,-10.84) -- (26.38,-11.73);
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (13.5,-19.6) -- (27.2,-19.6);
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (27.2,-19.6) -- (26.4,-19.1) -- (26.4,-20.1);
\end_layout

\begin_layout Plain Layout


\backslash
draw [black] (13.18,-20.96) -- (27.52,-28.24); 
\end_layout

\begin_layout Plain Layout


\backslash
fill [black] (27.52,-28.24) -- (27.04,-27.43) -- (26.59,-28.33);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\backslash
end{center} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il concetto è insoddisfacibile, ma senza la regola della scelta semplicemente
 non si assegnerebbe il concetto B a uno dei tre nodi, cosa che non può
 essere ragionevole in nessun modello (o vale B oppure vale 
\begin_inset Formula $\neg B$
\end_inset

).
\end_layout

\end_body
\end_document
